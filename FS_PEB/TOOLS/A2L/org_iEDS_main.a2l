/* -------------------------------------------------------------------------
                                                                             
                                  Visu-IT!                                   
                                                                             
                              ASAP2Toolkit DEMO                              
                                                                             
                              - ASAP2 export -                               
                                                                             
   -------------------------------------------------------------------------
	Version               13.2.R0
	Component-Version     Build<000000.18> 2017/07/24 18:34:50
	CreationDate          08 Jan 2018, 14:55:15
   -------------------------------------------------------------------------
	Project               TC27x
	Number                -
	Structure             -
	Serial Nr.            -
   -------------------------------------------------------------------------
	Option Project (DataBase)             demo
	Option Verbose                        false
	Option ASAP2File                      demo
	Option IgnoreAddressCheck             false
	Option ASAP2Version                   1.60
	Option PartialExportViaFunction       
	Option PartialExportViaFunctionMode   <2>
	Option CompuMethodName                <0>
	Option ExportUnitDisplayName          <0>
	Option IfDataTemplateList             
	Option A2MLMode                       <0>
	Option CalibrationMethodList          
	Option MemoryRegionAutoAssignment     <0>
	Option AddressOffset                  <0>
	Option A2LName                        EntityName
	Option ExportHiddenData               false
	Option ExportInvisibleData            false
	Option ExportSoftwareGrouping         false
	Option ExportComponentGrouping        false
	Option SuppressFunctionGrouping       false
	Option SuppressAxisFunctionGrouping   false
	Option SuppressDefaultFunction        false
	Option ExportDisplayIdentifier        <1>
	Option ExportLongIdentifier           <0>
	Option ExportAnnotation               false
	Option ExportReference2MemorySegment  false
	Option ExportSystemConstants          <0>
	Option CreateVirtualCharacteristics.. false
	Option CreateVirtualMeasurements4In.. false
	Option CreateSymbolLink               false
	Option SuppressEcuAddress             false
	Option SuppressFloat                  false
	Option SuppressVariantCoding          false
	Option VariantCodingMode              <0>
	Option OnlineOnly                     false
	Option Map2PointLinearConv2RatFunc    false
	Option NonLinearConvMode              <0>
	Option MapVTabRange2VTab              false
	Option MaxCompuTabValuePairs          <255>
	Option DefaultFormat4VerbalConvers... 
	Option WriteEscapeCharacters          false
	Option SASList                        
	Option SAS4All                        false
	Option ApplyOldIdentSyntax4NonInstr.. false
	Option IgnorePartialIdentLengthCheck  false
	Option AllowEmptyContainer            false
	Option CreateAddressOffsetFile        <0>
	Option SupportEdicMobileV3            false
	Option SuppressBitfieldCarrier        false
	Option DefaultLanguage                en
	Option SkipInputDefinitions           false
	Option Force1DValBlks                 false
	Option ExportMaxRefresh               <0>
	Option SuppressRefUnit                false
	Option ExportUnusedAttributes         false
	Option CustomAmlFiles                 
   ------------------------------------------------------------------------- */

ASAP2_VERSION 1 60
/begin PROJECT
   tc27x
   "default"
   /begin HEADER
      "iEDS MCU"
      VERSION "1.0"
      PROJECT_NO default
   /end HEADER
   /begin MODULE
      iEDS_MCU
      "default"

      /begin A2ML
/************************************************************************************/ 
/*                                                                                  */ 
/*   ASAP2 meta language for XCP protocol layer V1.0                                */ 
/*                                                                                  */ 
/*   2003-03-03                                                                     */ 
/*                                                                                  */ 
/*   Vector Informatik, Schuermans                                                  */ 
/*                                                                                  */ 
/*   Datatypes:                                                                     */ 
/*                                                                                  */ 
/*   A2ML       ASAP2             Windows      description                          */ 
/*   -------------------------------------------------------------------------------*/ 
/*   uchar      UBYTE             BYTE         unsigned 8 Bit                       */ 
/*   char       SBYTE             char         signed 8 Bit                         */ 
/*   uint       UWORD             WORD         unsigned integer 16 Bit              */ 
/*   int        SWORD             int          signed integer 16 Bit                */ 
/*   ulong      ULONG             DWORD        unsigned integer 32 Bit              */ 
/*   long       SLONG             LONG         signed integer 32 Bit                */ 
/*   float      FLOAT32_IEEE                   float 32 Bit                         */ 
/*                                                                                  */ 
/************************************************************************************/ 
/*********************** start of PROTOCOL_LAYER ****************************/ 
 
struct Protocol_Layer {     /* At MODULE */ 
 
  uint;                                /* XCP protocol layer version */ 
                                       /* e.g. "1.0" = 0x0100            */ 
 
  uint;                                /* T1 [ms] */ 
  uint;                                /* T2 [ms] */ 
  uint;                                /* T3 [ms] */ 
  uint;                                /* T4 [ms] */ 
  uint;                                /* T5 [ms] */ 
  uint;                                /* T6 [ms] */ 
  uint;                                /* T7 [ms] */ 
 
  uchar;                               /* MAX_CTO */ 
  uint;                                /* MAX_DTO */ 
 
  enum {                               /* BYTE_ORDER */ 
    "BYTE_ORDER_MSB_LAST"  = 0, 
    "BYTE_ORDER_MSB_FIRST" = 1 
  }; 
 
  enum {                               /* ADDRESS_GRANULARITY */ 
    "ADDRESS_GRANULARITY_BYTE"    = 1, 
    "ADDRESS_GRANULARITY_WORD"    = 2, 
    "ADDRESS_GRANULARITY_DWORD"   = 4 
  }; 
 
  taggedstruct {                       /* optional                     */ 
     
    ("OPTIONAL_CMD" enum {             /* XCP-Code of optional command */  
                                       /* supported by the slave       */ 
 
      "GET_COMM_MODE_INFO"       = 0xFB, 
      "GET_ID"                   = 0xFA, 
      "SET_REQUEST"              = 0xF9, 
      "GET_SEED"                 = 0xF8, 
      "UNLOCK"                   = 0xF7, 
      "SET_MTA"                  = 0xF6, 
      "UPLOAD"                   = 0xF5, 
      "SHORT_UPLOAD"             = 0xF4, 
      "BUILD_CHECKSUM"           = 0xF3, 
      "TRANSPORT_LAYER_CMD"      = 0xF2, 
      "USER_CMD"                 = 0xF1, 
      "DOWNLOAD"                 = 0xF0, 
      "DOWNLOAD_NEXT"            = 0xEF, 
      "DOWNLOAD_MAX"             = 0xEE, 
      "SHORT_DOWNLOAD"           = 0xED, 
      "MODIFY_BITS"              = 0xEC, 
      "SET_CAL_PAGE"             = 0xEB, 
      "GET_CAL_PAGE"             = 0xEA, 
      "GET_PAG_PROCESSOR_INFO"   = 0xE9, 
      "GET_SEGMENT_INFO"         = 0xE8, 
      "GET_PAGE_INFO"            = 0xE7, 
      "SET_SEGMENT_MODE"         = 0xE6, 
      "GET_SEGMENT_MODE"         = 0xE5, 
      "COPY_CAL_PAGE"            = 0xE4, 
      "CLEAR_DAQ_LIST"           = 0xE3, 
      "SET_DAQ_PTR"              = 0xE2, 
      "WRITE_DAQ"                = 0xE1, 
      "SET_DAQ_LIST_MODE"        = 0xE0, 
      "GET_DAQ_LIST_MODE"        = 0xDF, 
      "START_STOP_DAQ_LIST"      = 0xDE, 
      "START_STOP_SYNCH"         = 0xDD, 
      "GET_DAQ_CLOCK"            = 0xDC, 
      "READ_DAQ"                 = 0xDB, 
      "GET_DAQ_PROCESSOR_INFO"   = 0xDA, 
      "GET_DAQ_RESOLUTION_INFO"  = 0xD9, 
      "GET_DAQ_LIST_INFO"        = 0xD8, 
      "GET_DAQ_EVENT_INFO"       = 0xD7, 
      "FREE_DAQ"                 = 0xD6, 
      "ALLOC_DAQ"                = 0xD5, 
      "ALLOC_ODT"                = 0xD4, 
      "ALLOC_ODT_ENTRY"          = 0xD3, 
      "PROGRAM_START"            = 0xD2, 
      "PROGRAM_CLEAR"            = 0xD1, 
      "PROGRAM"                  = 0xD0, 
      "PROGRAM_RESET"            = 0xCF, 
      "GET_PGM_PROCESSOR_INFO"   = 0xCE, 
      "GET_SECTOR_INFO"          = 0xCD, 
      "PROGRAM_PREPARE"          = 0xCC, 
      "PROGRAM_FORMAT"           = 0xCB, 
      "PROGRAM_NEXT"             = 0xCA, 
      "PROGRAM_MAX"              = 0xC9, 
      "PROGRAM_VERIFY"           = 0xC8 
 
    })*;           
                                        
    "COMMUNICATION_MODE_SUPPORTED" taggedunion { /* optional modes supported */ 
       "BLOCK" taggedstruct { 
          "SLAVE";                  /* Slave Block Mode supported  */ 
          "MASTER" struct {         /* Master Block Mode supported */ 
             uchar;  /* MAX_BS */ 
             uchar;  /* MIN_ST */ 
          }; 
       }; 
       "INTERLEAVED" uchar;    /* QUEUE_SIZE */  
    }; 
 
    "SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];  /* Name of the Seed&Key function */ 
                                                 /* including file extension      */ 
                                                 /* without path                  */ 
  }; 
 
}; /********************* end of PROTOCOL_LAYER *****************************/ 
 
/***************************** start of DAQ *********************************/ 
struct Daq {                         /* DAQ supported, at MODULE*/ 
  enum {                             /* DAQ_CONFIG_TYPE */ 
    "STATIC"  = 0, 
    "DYNAMIC" = 1 
  }; 
 
  uint;                               /* MAX_DAQ */ 
  uint;                               /* MAX_EVENT_CHANNEL */ 
  uchar;                              /* MIN_DAQ */ 
 
  enum {                            /* OPTIMISATION_TYPE */ 
    "OPTIMISATION_TYPE_DEFAULT"            = 0, 
    "OPTIMISATION_TYPE_ODT_TYPE_16"        = 1, 
    "OPTIMISATION_TYPE_ODT_TYPE_32"        = 2, 
    "OPTIMISATION_TYPE_ODT_TYPE_64"        = 3, 
    "OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4, 
    "OPTIMISATION_TYPE_MAX_ENTRY_SIZE"     = 5 
  }; 
 
  enum {                           /* ADDRESS_EXTENSION */ 
    "ADDRESS_EXTENSION_FREE" = 0, 
    "ADDRESS_EXTENSION_ODT"  = 1, 
    "ADDRESS_EXTENSION_DAQ"  = 3 
  }; 
 
 
  enum {                           /* IDENTIFICATION_FIELD */ 
    "IDENTIFICATION_FIELD_TYPE_ABSOLUTE"              = 0, 
    "IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE"         = 1, 
    "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD"         = 2, 
    "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3 
  }; 
   
 
  enum {                        /* GRANULARITY_ODT_ENTRY_SIZE_DAQ */ 
    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE"    = 1, 
    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD"    = 2, 
    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD"   = 4, 
    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG"   = 8 
  }; 
 
  uchar;                              /* MAX_ODT_ENTRY_SIZE_DAQ */ 
 
  enum {                              /* OVERLOAD_INDICATION */ 
    "NO_OVERLOAD_INDICATION"    = 0, 
    "OVERLOAD_INDICATION_PID"   = 1, 
    "OVERLOAD_INDICATION_EVENT" = 2 
  }; 
 
  taggedstruct {                      /* optional */ 
    "PRESCALER_SUPPORTED"; 
    "RESUME_SUPPORTED"; 
 
    block "STIM" struct {             /* STIM supported */ 
 
      enum {                      /* GRANULARITY_ODT_ENTRY_SIZE_STIM */ 
        "GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE"   = 1, 
        "GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD"   = 2, 
        "GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD"  = 4, 
        "GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG"  = 8 
      }; 
 
      uchar;                          /* MAX_ODT_ENTRY_SIZE_STIM */ 
 
      taggedstruct {                  /* bitwise stimulation */ 
        "BIT_STIM_SUPPORTED"; 
      }; 
    }; 
           
    block "TIMESTAMP_SUPPORTED" struct {  
      uint;                           /* TIMESTAMP_TICKS */ 
      enum { /* TIMESTAMP_SIZE */ 
        "NO_TIME_STAMP" = 0, 
        "SIZE_BYTE"     = 1, 
        "SIZE_WORD"     = 2, 
        "SIZE_DWORD"    = 4 
      }; 
      enum { /* RESOLUTION OF TIMESTAMP */ 
        "UNIT_1NS"   = 0, 
        "UNIT_10NS"  = 1, 
        "UNIT_100NS" = 2, 
        "UNIT_1US"   = 3, 
        "UNIT_10US"  = 4, 
        "UNIT_100US" = 5, 
        "UNIT_1MS"   = 6, 
        "UNIT_10MS"  = 7, 
        "UNIT_100MS" = 8, 
        "UNIT_1S"    = 9 
      }; 
      taggedstruct { 
        "TIMESTAMP_FIXED"; 
      }; 
    }; 
 
    "PID_OFF_SUPPORTED"; 
 
    /************************ start of DAQ_LIST *************************/ 
 
    (block "DAQ_LIST" struct {          /* DAQ_LIST                    */ 
                                        /* multiple possible           */ 
      uint;                             /* DAQ_LIST_NUMBER             */ 
      taggedstruct {                            /* optional */ 
        "DAQ_LIST_TYPE" enum {               
          "DAQ"      = 1,               /* DIRECTION = DAQ only     */ 
          "STIM"     = 2,               /* DIRECTION = STIM only    */ 
          "DAQ_STIM" = 3                /* both directions possible */ 
                                        /* but not simultaneously   */ 
        }; 
 
        "MAX_ODT"         uchar;        /* MAX_ODT         */ 
        "MAX_ODT_ENTRIES" uchar;        /* MAX_ODT_ENTRIES */ 
 
        "FIRST_PID" uchar;              /* FIRST_PID for this DAQ_LIST */ 
        "EVENT_FIXED" uint;             /* this DAQ_LIST always        */ 
                                        /* in this event               */ 
        block "PREDEFINED" taggedstruct { /* predefined                */ 
                                          /* not configurable DAQ_LIST */ 
           (block "ODT" struct { 
                   uchar;                   /* ODT number */ 
                   taggedstruct { 
                       ("ODT_ENTRY" struct { 
                                   uchar;   /* ODT_ENTRY number            */ 
                                   ulong;   /* address of element                 */ 
                                   uchar;   /* address extension of element */ 
                                   uchar;   /* size of element [AG]                */ 
                                   uchar;   /* BIT_OFFSET                          */ 
                         })*; 
                   }; /* end of ODT_ENTRY */ 
            })*; /* end of ODT */ 
         }; /* end of PREDEFINED */ 
      }; 
    })*;/********************* end of DAQ_LIST ***************************/ 
 
    /************************* start of EVENT ****************************/ 
   
    (block "EVENT" struct {             /* EVENT               */ 
                                        /* multiple possible   */ 
      char[101];                        /* EVENT_CHANNEL_NAME       */ 
      char[9];                          /* EVENT_CHANNEL_SHORT_NAME */ 
      uint;                             /* EVENT_CHANNEL_NUMBER     */ 
   
      enum { 
        "DAQ"      = 1,                 /* only DAQ_LISTs         */ 
                                        /* with DIRECTION = DAQ   */ 
        "STIM"     = 2,                 /* only DAQ_LISTs         */ 
                                        /* with DIRECTION = STIM  */ 
        "DAQ_STIM" = 3                  /* both kind of DAQ_LISTs */ 
      }; 
   
      uchar;                            /* MAX_DAQ_LIST */ 
      uchar;                            /* TIME_CYCLE   */ 
      uchar;                            /* TIME_UNIT    */ 
      uchar;                            /* PRIORITY     */ 
   
    })*;/******************** end of EVENT ********************************/ 
 
  }; /* end of optional at DAQ */ 
 
}; /************************* end of DAQ *************************************/ 
 
 
/**************************** start of DAQ_EVENT *****************************/ 
 
taggedunion Daq_Event {         /* at MEASUREMENT */ 
   "FIXED_EVENT_LIST" taggedstruct { 
      ("EVENT" uint)* ; 
   }; 
   "VARIABLE" taggedstruct { 
      block "AVAILABLE_EVENT_LIST" taggedstruct { 
         ("EVENT" uint)*; 
      }; 
      block "DEFAULT_EVENT_LIST" taggedstruct { 
         ("EVENT" uint)*; 
      }; 
   }; 
}; /************************* end of DAQ_EVENT *******************************/ 
 
 
/**************************** start of PAG ***********************************/ 
 
struct Pag {                  /* PAG supported, at MODULE */ 
  uchar;                      /* MAX_SEGMENTS */ 
  taggedstruct {              /* optional */ 
    "FREEZE_SUPPORTED"; 
  }; 
 
}; /************************* end of PAG *************************************/ 
       
 
/**************************** start of PGM ***********************************/ 
 
struct Pgm {                  /* PGM supported, at MODULE */ 
 
  enum { 
    "PGM_MODE_ABSOLUTE"                = 1, 
    "PGM_MODE_FUNCTIONAL"              = 2, 
    "PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3 
  }; 
  uchar;                               /* MAX_SECTORS */ 
  uchar;                               /* MAX_CTO_PGM */ 

  taggedstruct {                       /* optional                */ 
    (block "SECTOR" struct {           /* SECTOR                  */ 
                                       /* multiple possible       */ 
      char[101];                       /* SECTOR_NAME             */ 
      uchar;                           /* SECTOR_NUMBER           */ 
      ulong;                           /* Address                 */ 
      ulong;                           /* Length                  */ 
      uchar;                           /* CLEAR_SEQUENCE_NUMBER   */ 
      uchar;                           /* PROGRAM_SEQUENCE_NUMBER */ 
      uchar;                           /* PROGRAM_METHOD          */ 
    })*; /* end of SECTOR */ 
                                        
    "COMMUNICATION_MODE_SUPPORTED" taggedunion { /* optional modes supported */ 
       "BLOCK" taggedstruct { 
          "SLAVE";                  /* Slave Block Mode supported  */ 
          "MASTER" struct {         /* Master Block Mode supported */ 
             uchar;  /* MAX_BS_PGM */ 
             uchar;  /* MIN_ST_PGM */ 
          }; 
       }; 
     "INTERLEAVED" uchar;    /* QUEUE_SIZE_PGM */  
     }; 
  }; 
}; /************************** end of PGM *************************************/ 
 
 
/***************************** start of SEGMENT *******************************/ 
 
struct Segment {               /* at MEMORY_SEGMENT */ 
  uchar;                               /* SEGMENT_NUMBER     */ 
  uchar;                               /* number of pages    */ 
  uchar;                               /* ADDRESS_EXTENSION  */ 
  uchar;                               /* COMPRESSION_METHOD */ 
  uchar;                               /* ENCRYPTION_METHOD  */ 
 
  taggedstruct {                       /* optional           */ 
    block "CHECKSUM" struct { 
      enum {                           /* checksum type      */ 
        "XCP_ADD_11"       =   1, 
        "XCP_ADD_12"       =   2, 
        "XCP_ADD_14"       =   3, 
        "XCP_ADD_22"       =   4, 
        "XCP_ADD_24"       =   5, 
        "XCP_ADD_44"       =   6, 
        "XCP_CRC_16"       =   7, 
        "XCP_CRC_16_CITT"  =   8, 
        "XCP_CRC_32"       =   9, 
        "XCP_USER_DEFINED" = 255 
      }; 
 
      taggedstruct { 
        "MAX_BLOCK_SIZE"              ulong ;    /* maximum block size            */ 
                                                 /* for checksum calculation      */ 
        "EXTERNAL_FUNCTION" char[256];           /* Name of the Checksum function */ 
                                                 /* including file extension      */ 
                                                 /* without path                  */ 
      }; 
    }; 
 
    (block "PAGE" struct {               /* PAGES for this SEGMENT */ 
                                         /* multiple possible      */ 
      uchar;                             /* PAGE_NUMBER            */ 
 
      enum {            /* ECU_ACCESS_TYPE */ 
          "ECU_ACCESS_NOT_ALLOWED"      = 0, 
          "ECU_ACCESS_WITHOUT_XCP_ONLY" = 1, 
          "ECU_ACCESS_WITH_XCP_ONLY"    = 2, 
          "ECU_ACCESS_DONT_CARE"        = 3 
       }; 
 
      enum {       /* XCP_READ_ACCESS_TYPE */ 
          "XCP_READ_ACCESS_NOT_ALLOWED"      = 0, 
          "XCP_READ_ACCESS_WITHOUT_ECU_ONLY" = 1, 
          "XCP_READ_ACCESS_WITH_ECU_ONLY"    = 2, 
          "XCP_READ_ACCESS_DONT_CARE"        = 3 
       }; 
 
      enum {      /* XCP_WRITE_ACCESS_TYPE */ 
          "XCP_WRITE_ACCESS_NOT_ALLOWED"      = 0, 
          "XCP_WRITE_ACCESS_WITHOUT_ECU_ONLY" = 1, 
          "XCP_WRITE_ACCESS_WITH_ECU_ONLY"    = 2, 
          "XCP_WRITE_ACCESS_DONT_CARE"        = 3 
      }; 
      taggedstruct { 
        "INIT_SEGMENT" uchar; /* references segment that initialises this page */ 
      }; 
 
    })*; /* end of PAGE */                 
 
    (block "ADDRESS_MAPPING" struct {  /* multiple possible   */ 
                         ulong;        /* source address      */ 
                         ulong;        /* destination address */ 
                         ulong;        /* length              */ 
    })*; 
 
    "PGM_VERIFY" ulong; /* verification value for PGM */ 
  }; /* end of optional */ 
 
}; /************************** end of SEGMENT *********************************/ 
 
/*********************** start of Common Parameters ***************************/ 
 
taggedstruct Common_Parameters {  
 
  block "PROTOCOL_LAYER" struct Protocol_Layer; 
 
  block "SEGMENT" struct Segment; 
 
  block "DAQ" struct Daq; 
  block "PAG" struct Pag; 
  block "PGM" struct Pgm; 
 
  block "DAQ_EVENT" taggedunion Daq_Event; 
 
}; /******************** end of Common Parameters *****************************/ 
/************************************************************************************/
/*                                                                                  */
/* ASAP2 meta language for XCP on CAN V1.0                                          */
/*                                                                                  */
/* 2003-03-03                                                                       */
/*                                                                                  */
/* Vector Informatik, Schuermans                                                    */
/*                                                                                  */
/* Datatypes:                                                                       */
/*                                                                                  */
/* A2ML ASAP2 Windows description                                                   */
/* ---------------------------------------------------------------------------------*/
/* uchar UBYTE BYTE unsigned 8 Bit                                                  */
/* char SBYTE char signed 8 Bit                                                     */
/* uint UWORD WORD unsigned integer 16 Bit                                          */
/* int SWORD int signed integer 16 Bit                                              */
/* ulong ULONG DWORD unsigned integer 32 Bit                                        */
/* long SLONG LONG signed integer 32 Bit                                            */
/* float FLOAT32_IEEE float 32 Bit                                                  */
/*                                                                                  */
/************************************************************************************/
/************************ start of CAN **********************************************/
struct CAN_Parameters { /* At MODULE */
  uint; /* XCP on CAN version */
        /* e.g. "1.0" = 0x0100 */
  taggedstruct { /* optional */
    "CAN_ID_BROADCAST" ulong; /* Auto detection CAN-ID */
                              /* master -> slaves */
                              /* Bit31= 1: extended identifier */
    "CAN_ID_MASTER" ulong;    /* CMD/STIM CAN-ID */
                              /* master -> slave */
                              /* Bit31= 1: extended identifier */
    "CAN_ID_SLAVE" ulong;     /* RES/ERR/EV/SERV/DAQ CAN-ID */
                              /* slave -> master */
                              /* Bit31= 1: extended identifier */
    "BAUDRATE" ulong;         /* BAUDRATE [Hz] */
    "SAMPLE_POINT" uchar;     /* sample point */
                              /* [% complete bit time] */
    "SAMPLE_RATE" enum {
      "SINGLE" = 1,           /* 1 sample per bit */
      "TRIPLE" = 3            /* 3 samples per bit */
    };
    "BTL_CYCLES" uchar;       /* BTL_CYCLES */
                              /* [slots per bit time] */
    "SJW" uchar;              /* length synchr. segment */
                              /* [BTL_CYCLES] */
    "SYNC_EDGE" enum {
      "SINGLE" = 1,           /* on falling edge only */
      "DUAL" = 2              /* on falling and rising edge */
    };
    "MAX_DLC_REQUIRED";       /* master to slave frames */
                              /* always to have DLC = MAX_DLC = 8 */
    (block "DAQ_LIST_CAN_ID" struct { /* At IF_DATA DAQ */
      uint;                   /* reference to DAQ_LIST_NUMBER */
      taggedstruct {          /* exclusive tags */
                              /* either VARIABLE or FIXED */
        "VARIABLE";
        "FIXED" ulong;        /* this DAQ_LIST always */
                              /* on this CAN_ID */
      };
    })*;
  };
};/************************* end of CAN ***********************************/

/************************************************************************************/
/*																												*/
/* ASAP2 meta language for XCP on FlexRay V1.0													*/
/*																												*/
/* 2005-10-13																								*/
/*																												*/
/************************************************************************************/



/************************ start of FLX **************************************/
enum packet_assignment_type {
	"NOT_ALLOWED",
	"FIXED",
	"VARIABLE_INITIALISED",
	"VARIABLE"
}; /* end of packet_assignment_type */

struct buffer {

	uchar; /* FLX_BUF */
	
	taggedstruct {

		"MAX_FLX_LEN_BUF" taggedunion {
			"FIXED" uchar; /* constant value */
			"VARIABLE" uchar; /* initial value */
		}; /* end of MAX_FLX_LEN_BUF */

		block "LPDU_ID" taggedstruct {
		
			"FLX_SLOT_ID" taggedunion {
				"FIXED" uint;
				"VARIABLE" taggedstruct{
					"INITIAL_VALUE" uint;
				};
			}; /* end of FLX_SLOT_ID */


			"OFFSET" taggedunion {
				"FIXED" uchar;
				"VARIABLE" taggedstruct{
					"INITIAL_VALUE" uchar;
				};
			}; /* end of OFFSET */


			"CYCLE_REPETITION" taggedunion {
				"FIXED" uchar;
				"VARIABLE" taggedstruct{
				"INITIAL_VALUE" uchar;
				};
			}; /* end of CYCLE_REPETITION */

			"CHANNEL" taggedunion {
				"FIXED" enum {
					"A" = 0,
					"B" = 1
				};
				"VARIABLE" taggedstruct{
					"INITIAL_VALUE" enum {
						"A" = 0,
						"B" = 1
					};
				};
			}; /* end of CHANNEL */
		}; /* end of LPDU_ID */


		block "XCP_PACKET" taggedstruct {
			"CMD" enum packet_assignment_type; /* end of CMD */
			"RES_ERR" enum packet_assignment_type; /* end of RES_ERR */
			"EV_SERV" enum packet_assignment_type; /* end of EV_SERV */
			"DAQ" enum packet_assignment_type; /* end of DAQ */
			"STIM" enum packet_assignment_type; /* end of STIM */
		}; /* end of XCP_PACKET */

	};
}; /* end of buffer */


struct FLX_Parameters {

	uint;			/* XCP on FlexRay version */
					/* e.g. "1.0" = 0x0100 */

	uint;			/* T1_FLX [ms] */

	char[256];	/* FIBEX-file including CHI information */
					/* including extension */
					/* without path */

	char[256];	/* Cluster-ID */
	uchar;		/* NAX */

	enum {
		"HEADER_NAX" = 0,
		"HEADER_NAX_FILL" = 1,
		"HEADER_NAX_CTR" = 2,
		"HEADER_NAX_FILL3" = 3,
		"HEADER_NAX_CTR_FILL2" = 4,
		"HEADER_NAX_LEN" = 5,
		"HEADER_NAX_CTR_LEN" = 6,
		"HEADER_NAX_FILL2_LEN" = 7,
		"HEADER_NAX_CTR_FILL_LEN" = 8
	};

	enum {
		"PACKET_ALIGNMENT_8" = 0,
		"PACKET_ALIGNMENT_16" = 1,
		"PACKET_ALIGNMENT_32" = 2
	};

	taggedunion {
		block "INITIAL_CMD_BUFFER" struct buffer;
	};

	taggedunion {
		block "INITIAL_RES_ERR_BUFFER" struct buffer;
	};

	taggedstruct {
		(block "POOL_BUFFER" struct buffer)*;
	};

};/************************* end of FLX ***********************************/
/************************** start of SxI ************************************/
struct SxI_Parameters { /* At MODULE */
  uint;  /* XCP on SxI version */
         /* e.g. "1.0" = 0x0100 */
  ulong; /* BAUDRATE [Hz] */
  taggedstruct { /* exclusive tags */
    "ASYNCH_FULL_DUPLEX_MODE" struct {
      enum {
        "PARITY_NONE" = 0,
        "PARITY_ODD" = 1,
        "PARITY_EVEN" = 2
        };
      enum {
        "ONE_STOP_BIT" = 1,
        "TWO_STOP_BITS" = 2
      };
    };
    "SYNCH_FULL_DUPLEX_MODE_BYTE";
    "SYNCH_FULL_DUPLEX_MODE_WORD";
    "SYNCH_FULL_DUPLEX_MODE_DWORD";
    "SYNCH_MASTER_SLAVE_MODE_BYTE";
    "SYNCH_MASTER_SLAVE_MODE_WORD";
    "SYNCH_MASTER_SLAVE_MODE_DWORD";
  };
  enum {
    "HEADER_LEN_BYTE" = 0,
    "HEADER_LEN_CTR_BYTE" = 1,
    "HEADER_LEN_FILL_BYTE" = 2,
    "HEADER_LEN_WORD" = 3,
    "HEADER_LEN_CTR_WORD" = 4,
    "HEADER_LEN_FILL_WORD" = 5
  };
  enum {
    "NO_CHECKSUM" = 0,
    "CHECKSUM_BYTE" = 1,
    "CHECKSUM_WORD" = 2
  };
};/*************************** end of SxI ***********************************/

/************************ start of TCP_IP ***********************************/

  struct TCP_IP_Parameters {

     uint; /* XCP on UDP_IP version */
           /* e.g. "1.0" = 0x0100 */
     uint; /* PORT */

     taggedunion {
       "HOST_NAME" char[256];
       "ADDRESS" char[15];
     };

 };/************************* end of TCP_IP ***********************************/

/************************** start of UDP ************************************/

  struct UDP_IP_Parameters {
     uint; /* XCP on UDP_IP version */
           /* e.g. "1.0" = 0x0100 */
     uint; /* PORT */

     taggedunion {
       "HOST_NAME" char[256];
       "ADDRESS" char[15];
     };

 };/*************************** end of UDP ***********************************/

/****************************************************************************/
/*                                                                          */
/* ASAP2 meta language for XCP protocol V1.0                                */
/* Assumes ASAP2 v1.3 or later                                              */
/*                                                                          */
/* AML version v2.0, 02.10.2002                                             */
/*                                                                          */
/* Robert Bosch GmbH                                                        */
/*                                                                          */
/****************************************************************************/
/************************ start of USB **************************************/
struct ep_parameters {
  uchar;                    /* ENDPOINT_NUMBER, not endpoint address */
  enum {
    "BULK_TRANSFER"      = 2,          /* Numbers according to USB spec. */
    "INTERRUPT_TRANSFER" = 3
  };
  uint;                              /* wMaxPacketSize: Maximum packet */
                                     /* size of endpoint in bytes */
  uchar;                             /* bInterval: polling of endpoint */
  enum {                             /* Packing of XCP Messages */
    "MESSAGE_PACKING_SINGLE"    = 0, /* Single per USB data packet */
    "MESSAGE_PACKING_MULTIPLE"  = 1, /* Multiple per USB data packet */
    "MESSAGE_PACKING_STREAMING" = 2  /* No restriction by packet sizes */
  };
  enum {                             /* Alignment mandatory for all */
    "ALIGNMENT_8_BIT" = 0,           /* packing types */
    "ALIGNMENT_16_BIT"= 1,
    "ALIGNMENT_32_BIT"= 2,
    "ALIGNMENT_64_BIT"= 3
  };
  taggedstruct {                     /* Optional */
    "RECOMMENDED_HOST_BUFSIZE" uint; /* Recommended size for the host */
                                     /* buffer size. The size is defined*/
                                     /* as multiple of wMaxPacketSize. */
  };
}; /* end of ep_parameters */
 
struct USB_Parameters {
  uint;                              /* XCP on USB version */
                                     /* e.g. 1.0 = 0x0100 */
  uint;                              /* Vendor ID */
  uint;                              /* Product ID */
  uchar;                             /* Number of interface */
  enum {
    "HEADER_LEN_BYTE"      = 0,
    "HEADER_LEN_CTR_BYTE"  = 1,
    "HEADER_LEN_FILL_BYTE" = 2,
    "HEADER_LEN_WORD"      = 3,
    "HEADER_LEN_CTR_WORD"  = 4,
    "HEADER_LEN_FILL_WORD" = 5
  };
  taggedunion {                      /* OUT-EP for CMD and */
                                     /* STIM (if not specified otherwise) */
    block "OUT_EP_CMD_STIM" struct ep_parameters;
  };
  taggedunion {                      /* IN-EP for RES/ERR, */
                                     /* DAQ (if not specified otherwise) and */
                                     /* EV/SERV (if not specified otherwise) */
    block "IN_EP_RESERR_DAQ_EVSERV" struct ep_parameters;
  };
  /* ----------- Begin of optional ------- */
  taggedstruct { /* Optional */
    "ALTERNATE_SETTING_NO" uchar;    /* Number of alternate setting */
                                     /* String Descriptor of XCP */
                                     /* interface */
    "INTERFACE_STRING_DESCRIPTOR" char [101];
                                     /* multiple OUT-EP's for STIM */
    (block "OUT_EP_ONLY_STIM" struct ep_parameters)*;
                                     /* multiple IN-EP's for DAQ */
    (block "IN_EP_ONLY_DAQ" struct ep_parameters)*;
                                     /* only one IN-EP for EV/SERV */
    block "IN_EP_ONLY_EVSERV" struct ep_parameters;
    (block "DAQ_LIST_USB_ENDPOINT" struct {
      uint;                          /* reference to DAQ_LIST_NUMBER */
      taggedstruct {                 /* only mentioned if not VARIABLE */
        "FIXED_IN" uchar;            /* this DAQ list always */
                                     /* ENDPOINT_NUMBER, not endpoint address */
        "FIXED_OUT" uchar;           /* this STIM list always */
                                     /* ENDPOINT_NUMBER, not endpoint address */
      };
    })*; /* end of DAQ_LIST_USB_ENDPOINT */
  }; /* end of optional */
};/************************* end of USB ***********************************/
         block "IF_DATA" taggedunion if_data {

/************* start of XCP on different Transport Layers *******************/

"XCP" struct {

  taggedstruct Common_Parameters ; /* default parameters */

  taggedstruct { /* transport layer specific parameters  */
                 /* overruling of the default parameters */

    block "XCP_ON_CAN" struct {

      struct CAN_Parameters ;                   /* specific for CAN      */
      taggedstruct Common_Parameters;           /* overruling of default */
    
    };

    block "XCP_ON_SxI" struct {

      struct SxI_Parameters ;                   /* specific for SPI      */
      taggedstruct Common_Parameters;           /* overruling of default */

    };

    block "XCP_ON_TCP_IP" struct {

      struct TCP_IP_Parameters ;                /* specific for TCP_IP   */
      taggedstruct Common_Parameters;           /* overruling of default */

    };

    block "XCP_ON_UDP_IP" struct {

      struct UDP_IP_Parameters ;                /* specific for UDP      */
      taggedstruct Common_Parameters;           /* overruling of default */

    };

    block "XCP_ON_USB" struct {

      struct USB_Parameters ;                   /* specific for USB      */
      taggedstruct Common_Parameters;           /* overruling of default */

    };

    block "XCP_ON_FLX" struct {

		struct FLX_Parameters ;                   /* specific for FlexRay  */
		taggedstruct Common_Parameters;           /* overruling of default */

    };

  };

};/************* end of XCP on different Transport Layers ********************/

         };
      /end A2ML

/************* 姝ゅ娣诲姞memory segment鐨勪俊鎭�?********************/

      /begin MOD_PAR "DEFAULT"
         /begin MEMORY_SEGMENT _RAM0
            ""
            DATA
            RAM
            INTERN
            0x70000000
            0x1C000
            -1 -1 -1 -1 -1
         /end MEMORY_SEGMENT

      /begin MEMORY_SEGMENT _PF0_INT
         	""
         	CODE
         	FLASH
         	INTERN
         	0x800F0000
         	0xFFFF
         	-1 -1 -1 -1 -1
         /end MEMORY_SEGMENT
          /begin MEMORY_SEGMENT _LMU
            ""
            DATA
            RAM
            INTERN
            0x9000000
            0x4000
            -1 -1 -1 -1 -1
         /end MEMORY_SEGMENT

         /begin MEMORY_SEGMENT _STARTUP
         	""
         	CODE
         	FLASH
         	INTERN
         	0xA0020000
         	0x24
         	-1 -1 -1 -1 -1
         /end MEMORY_SEGMENT

         /begin MEMORY_SEGMENT _PF1_CACHE
         	""
         	CODE
         	FLASH
         	INTERN
         	0xA00F0000
         	0xFFFF
         	-1 -1 -1 -1 -1
         /end MEMORY_SEGMENT

         /begin MEMORY_SEGMENT FR_DATA
          ""
          CODE
          FLASH
          INTERN
          0xA0180000
          0x10000
          -1 -1 -1 -1 -1
         /end MEMORY_SEGMENT

         /begin MEMORY_SEGMENT _CALROM
            ""
            DATA
            FLASH
            INTERN
            0x80140000
            0x8000
            -1 -1 -1 -1 -1
            /begin IF_DATA XCP
               /begin SEGMENT
                  0 
                  2 
                  0 
                  0 
                  0 
                  /begin CHECKSUM
                     XCP_ADD_14 
                  /end CHECKSUM
                  /begin PAGE
                     0 
                     ECU_ACCESS_WITH_XCP_ONLY 
                     XCP_READ_ACCESS_WITH_ECU_ONLY 
                     XCP_WRITE_ACCESS_NOT_ALLOWED 
                     INIT_SEGMENT 0 
                  /end PAGE
                  /begin PAGE
                     1 
                     ECU_ACCESS_WITH_XCP_ONLY 
                     XCP_READ_ACCESS_WITH_ECU_ONLY 
                     XCP_WRITE_ACCESS_WITH_ECU_ONLY 
                     INIT_SEGMENT 0 
                  /end PAGE
               /end SEGMENT
            /end IF_DATA
         /end MEMORY_SEGMENT

         /begin MEMORY_SEGMENT _ECU_CODE1
            ""
            CODE
            FLASH
            INTERN
            0x80000024
            0xE0000
            -1 -1 -1 -1 -1
         /end MEMORY_SEGMENT

         /begin MEMORY_SEGMENT _INT_RAM
            ""
            VARIABLES
            RAM
            INTERN
            0x70000000
            0x1C000
            -1 -1 -1 -1 -1
         /end MEMORY_SEGMENT

      /end MOD_PAR

      /begin MOD_COMMON "DEFAULT"
         DEPOSIT ABSOLUTE
         BYTE_ORDER MSB_LAST
         ALIGNMENT_BYTE 1
         ALIGNMENT_WORD 1
         ALIGNMENT_LONG 1
         ALIGNMENT_FLOAT32_IEEE 1
         ALIGNMENT_FLOAT64_IEEE 1
      /end MOD_COMMON

/****************浠ヤ笅鏇挎崲鎴愮敓鎴愮殑a2l妯℃�?*****************************/

     
/begin IF_DATA XCP                      /* Insert this block within the MODULE block of the A2L file. */

    /begin PROTOCOL_LAYER
    
        0x0100                          /* XCP protocol layer 1.0 */
        
        2000                  /* T1 [ms] */
        2000                  /* T2 [ms] */
        2000                  /* T3 [ms] */
        2000                  /* T4 [ms] */
        2000                  /* T5 [ms] */
        0005                  /* T6 [ms] */
        0005                  /* T7 [ms] */
        
        8                     /* MAX_CTO */
        8                     /* MAX_DTO */
        
        BYTE_ORDER_MSB_LAST
        ADDRESS_GRANULARITY_BYTE

        OPTIONAL_CMD SET_REQUEST
        OPTIONAL_CMD SET_MTA
        OPTIONAL_CMD UPLOAD
        OPTIONAL_CMD BUILD_CHECKSUM
        OPTIONAL_CMD TRANSPORT_LAYER_CMD
        OPTIONAL_CMD CLEAR_DAQ_LIST
        OPTIONAL_CMD SET_DAQ_PTR
        OPTIONAL_CMD WRITE_DAQ
        OPTIONAL_CMD SET_DAQ_LIST_MODE
        OPTIONAL_CMD START_STOP_DAQ_LIST
        OPTIONAL_CMD START_STOP_SYNCH
        OPTIONAL_CMD GET_DAQ_CLOCK
        
        
        
        OPTIONAL_CMD MODIFY_BITS
        OPTIONAL_CMD DOWNLOAD
        OPTIONAL_CMD DOWNLOAD_NEXT
        OPTIONAL_CMD SET_CAL_PAGE
        OPTIONAL_CMD GET_CAL_PAGE
        OPTIONAL_CMD COPY_CAL_PAGE
        
        
        

        COMMUNICATION_MODE_SUPPORTED
             BLOCK
                 SLAVE
                 MASTER
                 0xff                               /* MAX_BS */
                 100               /* MIN_ST */

        

    /end PROTOCOL_LAYER
    
    /begin DAQ
    
        STATIC                         /* DAQ_CONFIG_TYPE */
        
        3                                 /* MAX_DAQ */
        3                       /* MAX_EVENT_CHANNEL */
        0                                           /* MIN_DAQ, i.e. the number of predefined DAQ lists */
        
        OPTIMISATION_TYPE_DEFAULT
        ADDRESS_EXTENSION_DAQ                     /* ADDR_EXTENSION_TYPE */
        IDENTIFICATION_FIELD_TYPE_ABSOLUTE
        
        GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE
        8                  /* MAX_ODT_ENTRY_SIZE_DAQ */
        
        NO_OVERLOAD_INDICATION
        
        
        
        
        /begin TIMESTAMP_SUPPORTED
            1                     /* TIMESTAMP_TICKS */
            NO_TIME_STAMP                      /* TIMESTAMP_SIZE */
            UNIT_1MS                /* TIMESTAMP_RESOLUTION */
        /end TIMESTAMP_SUPPORTED
        
        
        
        /begin DAQ_LIST                             /* DAQ0 */
            0                     /* DAQ_LIST_NUMBER */
            DAQ_LIST_TYPE   DAQ
            MAX_ODT         5
            MAX_ODT_ENTRIES 7
            FIRST_PID       0
            EVENT_FIXED     0
        /end DAQ_LIST        
        /begin DAQ_LIST                             /* DAQ1 */
            1                     /* DAQ_LIST_NUMBER */
            DAQ_LIST_TYPE   DAQ
            MAX_ODT         10
            MAX_ODT_ENTRIES 7
            FIRST_PID       5
            EVENT_FIXED     1
        /end DAQ_LIST        
        /begin DAQ_LIST                             /* DAQ2 */
            2                     /* DAQ_LIST_NUMBER */
            DAQ_LIST_TYPE   DAQ
            MAX_ODT         20
            MAX_ODT_ENTRIES 7
            FIRST_PID       15
            EVENT_FIXED     2
        /end DAQ_LIST

        /begin EVENT
            "2ms_Raster"                /* EVENT_CHANNEL_NAME */
            "2msRstr"          /* EVENT_CHANNEL_SHORT_NAME */
            0                /* EVENT_CHANNEL_NUMBER */
            DAQ_STIM                                /* EVENT_CHANNEL_DIRECTION */
            0xff                                    /* MAX_DAQ_LIST */
            2            /* TIME_CYCLE */
            6             /* TIME_UNIT */
            0                                       /* PRIORITY */
        /end EVENT
        /begin EVENT
            "10ms_Raster"                /* EVENT_CHANNEL_NAME */
            "10msRstr"          /* EVENT_CHANNEL_SHORT_NAME */
            1                /* EVENT_CHANNEL_NUMBER */
            DAQ_STIM                                /* EVENT_CHANNEL_DIRECTION */
            0xff                                    /* MAX_DAQ_LIST */
            10            /* TIME_CYCLE */
            6             /* TIME_UNIT */
            0                                       /* PRIORITY */
        /end EVENT
        /begin EVENT
            "100ms_Raster"                /* EVENT_CHANNEL_NAME */
            "100msRstr"          /* EVENT_CHANNEL_SHORT_NAME */
            2                /* EVENT_CHANNEL_NUMBER */
            DAQ_STIM                                /* EVENT_CHANNEL_DIRECTION */
            0xff                                    /* MAX_DAQ_LIST */
            10            /* TIME_CYCLE */
            7             /* TIME_UNIT */
            0                                       /* PRIORITY */
        /end EVENT
        
    /end DAQ
    
    /begin PAG
        1                            /* MAX_SEGMENTS */
        FREEZE_SUPPORTED
    /end PAG
    
    /begin PGM
        PGM_MODE_ABSOLUTE
        0                             /* MAX_SECTORS */
        0x08                                        /* MAX_CTO_PGM */

         
        COMMUNICATION_MODE_SUPPORTED
             BLOCK
                 SLAVE
                 MASTER
                 0xff                               /* MAX_BS_PGM */
                 100               /* MIN_ST_PGM */
        
    /end PGM
    
    /begin XCP_ON_CAN
    
        0x0100                                      /* XCP on CAN 1.0 */
        CAN_ID_BROADCAST 0x210       /* auto-detection */
        CAN_ID_MASTER    0x220          /* CMD/STIM */
        CAN_ID_SLAVE     0x300           /* RES/ERR/EV/SERV/DAQ */
        BAUDRATE         1000000               /* In Hz */
        SAMPLE_POINT     75           /* Percentage of complete bit time. */
        SAMPLE_RATE      SINGLE
        BTL_CYCLES       0             /* Slots per bit time. */
        SJW              2                    /* Length of the synch segment. */
        SYNC_EDGE        SINGLE
        
        /begin DAQ_LIST_CAN_ID
            0                     /* DAQ_LIST_NUMBER */
            FIXED 0x310                 /* CAN msg ID */
        /end DAQ_LIST_CAN_ID        
        /begin DAQ_LIST_CAN_ID
            1                     /* DAQ_LIST_NUMBER */
            FIXED 0x311                 /* CAN msg ID */
        /end DAQ_LIST_CAN_ID        
        /begin DAQ_LIST_CAN_ID
            2                     /* DAQ_LIST_NUMBER */
            FIXED 0x312                 /* CAN msg ID */
        /end DAQ_LIST_CAN_ID

    /end XCP_ON_CAN


/end IF_DATA

      /****************姝や笂鏇挎崲鎴愮敓鎴愮殑a2l妯℃�?*****************************/

      

/begin COMPU_METHOD
    stDrvCtl_Verb
    ""
    TAB_VERB
    "%2.1"
    "-"
    COMPU_TAB_REF stDrvCtl_List
    
/end COMPU_METHOD

/begin COMPU_METHOD
    stSysCtl_Verb
    ""
    TAB_VERB
    "%2.1"
    "-"
    COMPU_TAB_REF stSysCtl_List
    
/end COMPU_METHOD

/begin COMPU_METHOD
    stDern_Verb
    ""
    TAB_VERB
    "%2.1"
    "-"
    COMPU_TAB_REF stDern_List
    
/end COMPU_METHOD


  /begin COMPU_VTAB

    stDrvCtl_List
    ""
    TAB_VERB
    20

    0 "Drv_Initial"
    1 "Drv_MocSop"
    2 "Drv_SensCalFW"
    3 "Drv_Standby"
    4 "Drv_Run"
    5 "Drv_OffsetAcc"
    6 "Drv_OffsetFw"
    7 "Drv_Discharge"
    8 "Drv_Failure"
    9 "Drv_TrqCtl"
   10 "Drv_nCtlExt"
   11 "Drv_inActive"
   12 "Drv_nCtlInt"
   13 "Drv_IsCtl"
   14 "Drv_UdcCtl"
   15 "Drv_UdcBatCtl"
   16 "Drv_FrWCtl"
   17 "Drv_Ready"
   18 "Drv_TestBench"
   19 "Drv_OffsetCal"

    DEFAULT_VALUE "---"
  /end COMPU_VTAB

  /begin COMPU_VTAB

    stSysCtl_List
    ""
    TAB_VERB
    4

    0 "PreDriveMod"
    1 "DriveMod"
    2 "PostDriveMod"
    3 "ShutDownMod"

    DEFAULT_VALUE "---"
  /end COMPU_VTAB

  /begin COMPU_VTAB

    stDern_List
    ""
    TAB_VERB
    9

    0 "bDern_Inactive"
    1 "bDern_ExCTrq"
    2 "bDern_StrTemp"
    3 "bDern_TempIGBT"
    4 "bDern_N"
    5 "bDern_OvrIdc"
    6 "bDern_UndrUdc"
    7 "bDern_OvrUdc"
    8 "bDern_CAN"

    DEFAULT_VALUE "---"
  /end COMPU_VTAB

   /end MODULE
/end PROJECT


/* -------------------------------------------------------------------------

	Visu-IT! - ASAP2Toolkit                 

   -------------------------------------------------------------------------
	Quality             FatalError<0> NonContinuationError<0> Error<0> Warning<1>
	Quantity            CURVE/MAP <0> VALUE<1> AXIS_PTS<0> MEASUREMENT<4>
   ------------------------------------------------------------------------- */

