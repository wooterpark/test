ASAP2_VERSION 1 60
/begin PROJECT  ETAS_AUTOSAR "XCP on CAN"

  /begin HEADER ""
    VERSION   "1.0.0.0"
    PROJECT_NO ETAS_AUTOSAR
  /end HEADER

  /begin MODULE ETAS_AUTOSAR    ""

 /begin A2ML 
/***********************************************************/
/*                                                         */
/* ASAP2 meta language for XCP protocol layer V1.2         */
/*                                                         */
/*                                                         */
/*   Datatypes:                                            */
/*                                                         */
/*   A2ML       description                                */
/*   ----------------------------------------------------- */
/*   uchar      unsigned 8  Bit                            */
/*   char       signed 8 Bit                               */
/*   uint       unsigned integer 16 Bit                    */
/*   int        signed integer 16 Bit                      */
/*   ulong      unsigned integer 32 Bit                    */
/*   long       signed integer 32 Bit                      */
/*   float      float 32 Bit IEEE 745                      */
/*                                                         */
/***********************************************************/

/*************** start of PROTOCOL_LAYER *******************/ 
   
  struct Protocol_Layer {     /* At MODULE */ 
   
    uint;                                /* XCP protocol layer version */ 
                                         /* e.g. "1.2" = 0x0102            */ 
   
    uint;                                /* T1 [ms] */ 
    uint;                                /* T2 [ms] */ 
    uint;                                /* T3 [ms] */ 
    uint;                                /* T4 [ms] */ 
    uint;                                /* T5 [ms] */ 
    uint;                                /* T6 [ms] */ 
    uint;                                /* T7 [ms] */ 
   
    uchar;                               /* MAX_CTO */ 
    uint;                                /* MAX_DTO default for DAQ and STIM */ 
   
    enum {                               /* BYTE_ORDER */ 
      "BYTE_ORDER_MSB_LAST"  = 0, 
      "BYTE_ORDER_MSB_FIRST" = 1 
    }; 
   
    enum {                               /* ADDRESS_GRANULARITY */ 
      "ADDRESS_GRANULARITY_BYTE"    = 1, 
      "ADDRESS_GRANULARITY_WORD"    = 2, 
      "ADDRESS_GRANULARITY_DWORD"   = 4 
    }; 
   
    taggedstruct {                       /* optional                     */ 
       
      ("OPTIONAL_CMD" enum {             /* XCP-Code of optional command */  
                                         /* supported by the slave       */ 
   
        "GET_COMM_MODE_INFO"       = 0xFB, 
        "GET_ID"                   = 0xFA, 
        "SET_REQUEST"              = 0xF9, 
        "GET_SEED"                 = 0xF8, 
        "UNLOCK"                   = 0xF7, 
        "SET_MTA"                  = 0xF6, 
        "UPLOAD"                   = 0xF5, 
        "SHORT_UPLOAD"             = 0xF4, 
        "BUILD_CHECKSUM"           = 0xF3, 
        "TRANSPORT_LAYER_CMD"      = 0xF2, 
        "USER_CMD"                 = 0xF1, 
        "DOWNLOAD"                 = 0xF0, 
        "DOWNLOAD_NEXT"            = 0xEF, 
        "DOWNLOAD_MAX"             = 0xEE, 
        "SHORT_DOWNLOAD"           = 0xED, 
        "MODIFY_BITS"              = 0xEC, 
        "SET_CAL_PAGE"             = 0xEB, 
        "GET_CAL_PAGE"             = 0xEA, 
        "GET_PAG_PROCESSOR_INFO"   = 0xE9, 
        "GET_SEGMENT_INFO"         = 0xE8, 
        "GET_PAGE_INFO"            = 0xE7, 
        "SET_SEGMENT_MODE"         = 0xE6, 
        "GET_SEGMENT_MODE"         = 0xE5, 
        "COPY_CAL_PAGE"            = 0xE4, 
        "CLEAR_DAQ_LIST"           = 0xE3, 
        "SET_DAQ_PTR"              = 0xE2, 
        "WRITE_DAQ"                = 0xE1, 
        "SET_DAQ_LIST_MODE"        = 0xE0, 
        "GET_DAQ_LIST_MODE"        = 0xDF, 
        "START_STOP_DAQ_LIST"      = 0xDE, 
        "START_STOP_SYNCH"         = 0xDD, 
        "GET_DAQ_CLOCK"            = 0xDC, 
        "READ_DAQ"                 = 0xDB, 
        "GET_DAQ_PROCESSOR_INFO"   = 0xDA, 
        "GET_DAQ_RESOLUTION_INFO"  = 0xD9, 
        "GET_DAQ_LIST_INFO"        = 0xD8, 
        "GET_DAQ_EVENT_INFO"       = 0xD7, 
        "FREE_DAQ"                 = 0xD6, 
        "ALLOC_DAQ"                = 0xD5, 
        "ALLOC_ODT"                = 0xD4, 
        "ALLOC_ODT_ENTRY"          = 0xD3, 
        "PROGRAM_START"            = 0xD2, 
        "PROGRAM_CLEAR"            = 0xD1, 
        "PROGRAM"                  = 0xD0, 
        "PROGRAM_RESET"            = 0xCF, 
        "GET_PGM_PROCESSOR_INFO"   = 0xCE, 
        "GET_SECTOR_INFO"          = 0xCD, 
        "PROGRAM_PREPARE"          = 0xCC, 
        "PROGRAM_FORMAT"           = 0xCB, 
        "PROGRAM_NEXT"             = 0xCA, 
        "PROGRAM_MAX"              = 0xC9, 
        "PROGRAM_VERIFY"           = 0xC8,
        "WRITE_DAQ_MULTIPLE"       = 0xC7
      })*;           
                                          
      "COMMUNICATION_MODE_SUPPORTED" taggedunion { /* optional modes supported */ 
         "BLOCK" taggedstruct { 
            "SLAVE";                  /* Slave Block Mode supported  */ 
            "MASTER" struct {         /* Master Block Mode supported */ 
               uchar;  /* MAX_BS */ 
               uchar;  /* MIN_ST */ 
            }; 
         }; 
         "INTERLEAVED" uchar;    /* QUEUE_SIZE */  
      }; 
   
      "SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];  /* Name of the Seed&Key function */ 
                                                   /* including file extension      */ 
                                                   /* without path                  */ 
      "MAX_DTO_STIM" uint;     /* overrules MAX_DTO see above for STIM use case */                                           
    }; 
   
  };

/***************** end of PROTOCOL_LAYER *******************/ 


/*********************** start of DAQ **********************/ 

  struct Daq {                         /* DAQ supported, at MODULE*/ 
    enum {                             /* DAQ_CONFIG_TYPE */ 
      "STATIC"  = 0, 
      "DYNAMIC" = 1 
    }; 
   
    uint;                               /* MAX_DAQ */ 
    uint;                               /* MAX_EVENT_CHANNEL */ 
    uchar;                              /* MIN_DAQ */ 
   
    enum {                            /* OPTIMISATION_TYPE */ 
      "OPTIMISATION_TYPE_DEFAULT"            = 0, 
      "OPTIMISATION_TYPE_ODT_TYPE_16"        = 1, 
      "OPTIMISATION_TYPE_ODT_TYPE_32"        = 2, 
      "OPTIMISATION_TYPE_ODT_TYPE_64"        = 3, 
      "OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4, 
      "OPTIMISATION_TYPE_MAX_ENTRY_SIZE"     = 5 
    }; 
   
    enum {                           /* ADDRESS_EXTENSION */ 
      "ADDRESS_EXTENSION_FREE" = 0, 
      "ADDRESS_EXTENSION_ODT"  = 1, 
      "ADDRESS_EXTENSION_DAQ"  = 3 
    }; 
   
   
    enum {                           /* IDENTIFICATION_FIELD */ 
      "IDENTIFICATION_FIELD_TYPE_ABSOLUTE"              = 0, 
      "IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE"         = 1, 
      "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD"         = 2, 
      "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3 
    }; 
     
   
    enum {                        /* GRANULARITY_ODT_ENTRY_SIZE_DAQ */ 
      "GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE"    = 1, 
      "GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD"    = 2, 
      "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD"   = 4, 
      "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG"   = 8 
    }; 
   
    uchar;                              /* MAX_ODT_ENTRY_SIZE_DAQ */ 
   
    enum {                              /* OVERLOAD_INDICATION */ 
      "NO_OVERLOAD_INDICATION"    = 0, 
      "OVERLOAD_INDICATION_PID"   = 1, 
      "OVERLOAD_INDICATION_EVENT" = 2 
    }; 
   
    taggedstruct {                      /* optional */ 
      "DAQ_ALTERNATING_SUPPORTED" uint; /* Display_Event_Channel_Number */
      "PRESCALER_SUPPORTED"; 
      "RESUME_SUPPORTED"; 
      "STORE_DAQ_SUPPORTED";
   
      block "STIM" struct {             /* STIM supported */ 
   
        enum {                      /* GRANULARITY_ODT_ENTRY_SIZE_STIM */ 
          "GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE"   = 1, 
          "GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD"   = 2, 
          "GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD"  = 4, 
          "GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG"  = 8 
        }; 
   
        uchar;                          /* MAX_ODT_ENTRY_SIZE_STIM */ 
   
        taggedstruct {                  /* bitwise stimulation */ 
          "BIT_STIM_SUPPORTED"; 
          "MIN_ST_STIM" uchar; /* separation time between DTOs */
          /* time in units of 100 microseconds */
        }; 
      }; 
             
      block "TIMESTAMP_SUPPORTED" struct {  
        uint;                           /* TIMESTAMP_TICKS */ 
        enum { /* TIMESTAMP_SIZE */ 
          "NO_TIME_STAMP" = 0, 
          "SIZE_BYTE"     = 1, 
          "SIZE_WORD"     = 2, 
          "SIZE_DWORD"    = 4 
        }; 
        enum { /* RESOLUTION OF TIMESTAMP */ 
          "UNIT_1NS"   = 0, 
          "UNIT_10NS"  = 1, 
          "UNIT_100NS" = 2, 
          "UNIT_1US"   = 3, 
          "UNIT_10US"  = 4, 
          "UNIT_100US" = 5, 
          "UNIT_1MS"   = 6, 
          "UNIT_10MS"  = 7, 
          "UNIT_100MS" = 8, 
          "UNIT_1S"    = 9, 
          "UNIT_1PS"   = 10,
          "UNIT_10PS"  = 11,
          "UNIT_100PS" = 12
        }; 
        taggedstruct { 
          "TIMESTAMP_FIXED"; 
        }; 
      }; 
   
      "PID_OFF_SUPPORTED";
  
      "MAX_DAQ_TOTAL" uint;
      "MAX_ODT_TOTAL" uint;
      "MAX_ODT_DAQ_TOTAL" uint;
      "MAX_ODT_STIM_TOTAL" uint;
      "MAX_ODT_ENTRIES_TOTAL" uint;
	  "MAX_ODT_ENTRIES_DAQ_TOTAL" uint;
      "MAX_ODT_ENTRIES_STIM_TOTAL" uint;

      
      "CPU_LOAD_MAX_TOTAL" float;
      
      block "DAQ_MEMORY_CONSUMPTION" struct {
        ulong; /* "DAQ_MEMORY_LIMIT"		: in Elements[AG] */
        uint;  /* "DAQ_SIZE" 			: Anzahl Elements[AG] pro DAQ-Liste */
        uint;  /* "ODT_SIZE" 			: Anzahl Elements[AG] pro ODT */
        uint;  /* "ODT_ENTRY_SIZE" 		: Anzahl Elements[AG] pro ODT_Entry */
        uint;  /* "ODT_DAQ_BUFFER_ELEMENT_SIZE" : Anzahl Payload-Elements[AG]*Faktor = sizeof(Sendepuffer)[AG] */
        uint;  /* "ODT_STIM_BUFFER_ELEMENT_SIZE": Anzahl Payload-Elements[AG]*Faktor = sizeof(Empfangspuffer)[AG] */
      };
       
      /************************ start of DAQ_LIST *************************/ 
   
      (block "DAQ_LIST" struct {          /* DAQ_LIST                    */ 
                                          /* multiple possible           */ 
        uint;                             /* DAQ_LIST_NUMBER             */ 
        taggedstruct {                            /* optional */ 
          "DAQ_LIST_TYPE" enum {               
            "DAQ"      = 1,               /* DIRECTION = DAQ only     */ 
            "STIM"     = 2,               /* DIRECTION = STIM only    */ 
            "DAQ_STIM" = 3                /* both directions possible */ 
                                          /* but not simultaneously   */ 
          }; 
   
          "MAX_ODT"         uchar;        /* MAX_ODT         */ 
          "MAX_ODT_ENTRIES" uchar;        /* MAX_ODT_ENTRIES */ 
   
          "FIRST_PID" uchar;              /* FIRST_PID for this DAQ_LIST */ 
          "EVENT_FIXED" uint;             /* this DAQ_LIST always        */ 
                                          /* in this event               */ 
          block "PREDEFINED" taggedstruct { /* predefined                */ 
                                            /* not configurable DAQ_LIST */ 
             (block "ODT" struct { 
                     uchar;                   /* ODT number */ 
                     taggedstruct { 
                         ("ODT_ENTRY" struct { 
                                     uchar;   /* ODT_ENTRY number            */ 
                                     ulong;   /* address of element                 */ 
                                     uchar;   /* address extension of element */ 
                                     uchar;   /* size of element [AG]                */ 
                                     uchar;   /* BIT_OFFSET                          */ 
                           })*; 
                     }; /* end of ODT_ENTRY */ 
              })*; /* end of ODT */ 
           }; /* end of PREDEFINED */ 
        }; 
      
      })*;
      
      /********************* end of DAQ_LIST ***************************/ 
   
      /************************* start of EVENT ************************/ 
     
      (block "EVENT" struct {             /* EVENT               */ 
                                          /* multiple possible   */ 
        char[101];                        /* EVENT_CHANNEL_NAME       */ 
        char[9];                          /* EVENT_CHANNEL_SHORT_NAME */ 
        uint;                             /* EVENT_CHANNEL_NUMBER     */ 
     
        enum { 
          "DAQ"      = 1,                 /* only DAQ_LISTs         */ 
                                          /* with DIRECTION = DAQ   */ 
          "STIM"     = 2,                 /* only DAQ_LISTs         */ 
                                          /* with DIRECTION = STIM  */ 
          "DAQ_STIM" = 3                  /* both kind of DAQ_LISTs */ 
        }; 
     
        uchar;                            /* MAX_DAQ_LIST */ 
        uchar;                            /* EVENT_CHANNEL_TIME_CYCLE */
        uchar;                            /* EVENT_CHANNEL_TIME_UNIT */ 
        uchar;                            /* EVENT_CHANNEL_PRIORITY */ 
          taggedstruct { /* optional */
            
            "COMPLEMENTARY_BYPASS_EVENT_CHANNEL_NUMBER" uint;
            "CONSISTENCY" enum {
  
                 "DAQ" = 0,
                 "EVENT" = 1
            };
           
            block "MIN_CYCLE_TIME" struct { /* Configuration with 0-0 not allowed */
             uchar;                            /* EVENT_CHANNEL_TIME_CYCLE */
             uchar;                            /* EVENT_CHANNEL_TIME_UNIT  */
            };
           
           "CPU_LOAD_MAX" float;
          
           block "CPU_LOAD_CONSUMPTION_DAQ" struct {
            float;  // "DAQ_FACTOR"
            float;  // "ODT_FACTOR"
            float;  // "ODT_ENTRY_FACTOR" 
            taggedstruct { 
              (block "ODT_ENTRY_SIZE_FACTOR_TABLE" struct{// Kopierroutine
                     uint; //"SIZE" 
                     float; // "SIZE_FACTOR" 
               })*;
             };
           };
           
           block "CPU_LOAD_CONSUMPTION_STIM" struct {
            float;  // "DAQ_FACTOR"
            float;  // "ODT_FACTOR"
            float;  // "ODT_ENTRY_FACTOR" 
            taggedstruct { 
              (block "ODT_ENTRY_SIZE_FACTOR_TABLE" struct{// Kopierroutine
                     uint; //"SIZE" 
                     float; //"SIZE_FACTOR" 
               })*;
             };
           };
           
           block "CPU_LOAD_CONSUMPTION_QUEUE" struct {
              float;  // "ODT_FACTOR" 
              float;  // "ODT_ELEMENT_LOAD",length in elements[AG]
           };        
         };
      })*;
      
      /******************** end of EVENT *********************/ 
   
    }; /* end of optional at DAQ */ 
   
  }; 
  
/********************* end of DAQ **************************/  
  

/***************** start of DAQ_EVENT **********************/ 
 
  taggedunion Daq_Event {         /* at MEASUREMENT */ 
     "FIXED_EVENT_LIST" taggedstruct { 
        ("EVENT" uint)* ; 
     }; 
     "VARIABLE" taggedstruct { 
        block "AVAILABLE_EVENT_LIST" taggedstruct { 
           ("EVENT" uint)*; 
        }; 
        block "DEFAULT_EVENT_LIST" taggedstruct { 
           ("EVENT" uint)*; 
        }; 
     }; 
  }; 

/******************** end of DAQ_EVENT *********************/ 
   

/*********************** start of PAG **********************/ 
   
  struct Pag {                  /* PAG supported, at MODULE */ 
    uchar;                      /* MAX_SEGMENTS */ 
    taggedstruct {              /* optional */ 
      "FREEZE_SUPPORTED"; 
    }; 
   
  }; 

/*********************** end of PAG ************************/ 
      

/*********************** start of PGM **********************/ 
   
  struct Pgm {                  /* PGM supported, at MODULE */ 
   
    enum { 
      "PGM_MODE_ABSOLUTE"                = 1, 
      "PGM_MODE_FUNCTIONAL"              = 2, 
      "PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3 
    }; 
    uchar;                               /* MAX_SECTORS */ 
    uchar;                               /* MAX_CTO_PGM */ 
  
    taggedstruct {                       /* optional                */ 
      (block "SECTOR" struct {           /* SECTOR                  */ 
                                         /* multiple possible       */ 
        char[101];                       /* SECTOR_NAME             */ 
        uchar;                           /* SECTOR_NUMBER           */ 
        ulong;                           /* Address                 */ 
        ulong;                           /* Length                  */ 
        uchar;                           /* CLEAR_SEQUENCE_NUMBER   */ 
        uchar;                           /* PROGRAM_SEQUENCE_NUMBER */ 
        uchar;                           /* PROGRAM_METHOD          */ 
      })*; /* end of SECTOR */ 
                                          
      "COMMUNICATION_MODE_SUPPORTED" taggedunion { /* optional modes supported */ 
         "BLOCK" taggedstruct { 
            "SLAVE";                  /* Slave Block Mode supported  */ 
            "MASTER" struct {         /* Master Block Mode supported */ 
               uchar;  /* MAX_BS_PGM */ 
               uchar;  /* MIN_ST_PGM */ 
            }; 
         }; 
       "INTERLEAVED" uchar;    /* QUEUE_SIZE_PGM */  
       }; 
    }; 
  }; 

/*********************** end of PGM ************************/ 

  
/*********************** start of SEGMENT ******************/ 
   
  struct Segment {               /* at MEMORY_SEGMENT */ 
    uchar;                               /* SEGMENT_NUMBER     */ 
    uchar;                               /* number of pages    */ 
    uchar;                               /* ADDRESS_EXTENSION  */ 
    uchar;                               /* COMPRESSION_METHOD */ 
    uchar;                               /* ENCRYPTION_METHOD  */ 
   
    taggedstruct {                       /* optional           */ 
      block "CHECKSUM" struct { 
        enum {                           /* checksum type      */ 
          "XCP_ADD_11"       =   1, 
          "XCP_ADD_12"       =   2, 
          "XCP_ADD_14"       =   3, 
          "XCP_ADD_22"       =   4, 
          "XCP_ADD_24"       =   5, 
          "XCP_ADD_44"       =   6, 
          "XCP_CRC_16"       =   7, 
          "XCP_CRC_16_CITT"  =   8, 
          "XCP_CRC_32"       =   9, 
          "XCP_USER_DEFINED" = 255 
        }; 
   
        taggedstruct { 
          "MAX_BLOCK_SIZE"              ulong ;    /* maximum block size            */ 
                                                   /* for checksum calculation      */ 
          "EXTERNAL_FUNCTION" char[256];           /* Name of the Checksum function */ 
                                                   /* including file extension      */ 
                                                   /* without path                  */ 
        }; 
      }; 
   
      (block "PAGE" struct {               /* PAGES for this SEGMENT */ 
                                           /* multiple possible      */ 
        uchar;                             /* PAGE_NUMBER            */ 
   
        enum {            /* ECU_ACCESS_TYPE */ 
            "ECU_ACCESS_NOT_ALLOWED"      = 0, 
            "ECU_ACCESS_WITHOUT_XCP_ONLY" = 1, 
            "ECU_ACCESS_WITH_XCP_ONLY"    = 2, 
            "ECU_ACCESS_DONT_CARE"        = 3 
         }; 
   
        enum {       /* XCP_READ_ACCESS_TYPE */ 
            "XCP_READ_ACCESS_NOT_ALLOWED"      = 0, 
            "XCP_READ_ACCESS_WITHOUT_ECU_ONLY" = 1, 
            "XCP_READ_ACCESS_WITH_ECU_ONLY"    = 2, 
            "XCP_READ_ACCESS_DONT_CARE"        = 3 
         }; 
   
        enum {      /* XCP_WRITE_ACCESS_TYPE */ 
            "XCP_WRITE_ACCESS_NOT_ALLOWED"      = 0, 
            "XCP_WRITE_ACCESS_WITHOUT_ECU_ONLY" = 1, 
            "XCP_WRITE_ACCESS_WITH_ECU_ONLY"    = 2, 
            "XCP_WRITE_ACCESS_DONT_CARE"        = 3 
        }; 
        taggedstruct { 
          "INIT_SEGMENT" uchar; /* references segment that initialises this page */ 
        }; 
   
      })*; /* end of PAGE */                 
   
      (block "ADDRESS_MAPPING" struct {  /* multiple possible   */ 
                           ulong;        /* source address      */ 
                           ulong;        /* destination address */ 
                           ulong;        /* length              */ 
      })*; 
   
      "PGM_VERIFY" ulong; /* verification value for PGM */ 
    }; /* end of optional */ 
   
  }; 

/************************ end of SEGMENT *******************/ 

  
/*********************** start of Common Parameters ********/ 
 
  taggedstruct Common_Parameters {  
   
    block "PROTOCOL_LAYER" struct Protocol_Layer; 
   
    block "SEGMENT" struct Segment; 
   
    block "DAQ" struct Daq; 
    block "PAG" struct Pag; 
    block "PGM" struct Pgm; 
   
    block "DAQ_EVENT" taggedunion Daq_Event; 
   
  }; 

/********************** end of Common Parameters **********/ 


/***********************************************************/
/*                                                         */
/* ASAP2 meta language for XCP on CAN V1.2                 */
/*                                                         */
/*                                                         */
/*   Datatypes:                                            */
/*                                                         */
/*   A2ML       description                                */
/*   ----------------------------------------------------- */
/*   uchar      unsigned 8  Bit                            */
/*   char       signed 8 Bit                               */
/*   uint       unsigned integer 16 Bit                    */
/*   int        signed integer 16 Bit                      */
/*   ulong      unsigned integer 32 Bit                    */
/*   long       signed integer 32 Bit                      */
/*   float      float 32 Bit IEEE 745                      */
/*                                                         */
/***********************************************************/
/************************ start of CAN *********************/

  struct CAN_Parameters { /* At MODULE */
    uint; /* XCP on CAN version */
          /* e.g. "1.2" = 0x0102 */
    taggedstruct { /* optional */
      "CAN_ID_BROADCAST" ulong; /* Auto detection CAN-ID */
                                /* master -> slaves */
                                /* Bit31= 1: extended identifier */
      "CAN_ID_MASTER" ulong;    /* CMD/STIM CAN-ID */
                                /* master -> slave */
                                /* Bit31= 1: extended identifier */
      "CAN_ID_MASTER_INCREMENTAL";     /* master uses range of CAN-IDs  */
                                /* start of range = CAN_ID_MASTER */
                                /* end of range = CAN_ID_MASTER+MAX_BS(_PGM)-1 */
      "CAN_ID_SLAVE" ulong;     /* RES/ERR/EV/SERV/DAQ CAN-ID */
                                /* slave -> master */
                                /* Bit31= 1: extended identifier */
      "BAUDRATE" ulong;         /* BAUDRATE [Hz] */
      "SAMPLE_POINT" uchar;     /* sample point */
                                /* [% complete bit time] */
      "SAMPLE_RATE" enum {
        "SINGLE" = 1,           /* 1 sample per bit */
        "TRIPLE" = 3            /* 3 samples per bit */
      };
      "BTL_CYCLES" uchar;       /* BTL_CYCLES */
                                /* [slots per bit time] */
      "SJW" uchar;              /* length synchr. segment */
                                /* [BTL_CYCLES] */
      "SYNC_EDGE" enum {
        "SINGLE" = 1,           /* on falling edge only */
        "DUAL" = 2              /* on falling and rising edge */
      };
      "MAX_DLC_REQUIRED";       /* master to slave frames */
                                /* always to have DLC = MAX_DLC = 8 */
                              
      (block "DAQ_LIST_CAN_ID" struct { /* At IF_DATA DAQ */
        uint;                   /* reference to DAQ_LIST_NUMBER */
        taggedstruct {          /* exclusive tags */
                                /* either VARIABLE or FIXED */
          "VARIABLE";
          "FIXED" ulong;        /* this DAQ_LIST always */
                                /* on this CAN_ID */
        };
      })*;
      (block "EVENT_CAN_ID_LIST" struct { /* At IF_DATA DAQ  */
        uint;                   /* reference to EVENT_NUMBER */
        taggedstruct {          /* exclusive tags */
          ("FIXED" ulong)*;        /* this Event always on this ID */
        };
      })*;
        
      "MAX_BUS_LOAD"  ulong;    /* maximum available bus */
                                   /* load in percent */
  
      block "CAN_FD" struct {
        taggedstruct {

          "MAX_DLC" uint; /* 8, 12, 16, 20, 24, 32, 48 or 64 */
          "CAN_FD_DATA_TRANSFER_BAUDRATE" ulong; /* BAUDRATE [Hz] */
 
          "SAMPLE_POINT" uchar;   /* sample point receiver*/
                                      /* [% complete bit time] */
        
          "BTL_CYCLES" uchar;            /* BTL_CYCLES        */
                                     /* [slots per bit time]   */
          "SJW" uchar;              /* length synchr. segment */
                                     /* [BTL_CYCLES]           */
          "SYNC_EDGE" enum {
                       "SINGLE" = 1, /* on falling edge only */
                       "DUAL"   = 2  /* on falling and rising edge*/
                     };
  
          "MAX_DLC_REQUIRED";      /* master to slave frames */
                         /* always to have DLC = MAX_DLC_for CAN-FD */
  
          "SECONDARY_SAMPLE_POINT" uchar;/* sender sample point */
                                     /* [% complete bit time] */
          "TRANSCEIVER_DELAY_COMPENSATION" enum {
                         "OFF" = 0,
                         "ON" = 1
          };
                       
        };
        
      };
      
    };
    
  };

/************************* end of CAN **********************/


/***********************************************************/
/*                                                         */
/* ASAP2 meta language for XCP on TCP_IP V1.2              */
/*                                                         */
/*                                                         */
/*   Datatypes:                                            */
/*                                                         */
/*   A2ML       description                                */
/*   ----------------------------------------------------- */
/*   uchar      unsigned 8  Bit                            */
/*   char       signed 8 Bit                               */
/*   uint       unsigned integer 16 Bit                    */
/*   int        signed integer 16 Bit                      */
/*   ulong      unsigned integer 32 Bit                    */
/*   long       signed integer 32 Bit                      */
/*   float      float 32 Bit IEEE 745                      */
/*                                                         */
/***********************************************************/
/************************ start of TCP_IP ******************/

  struct TCP_IP_Parameters {

     uint; /* XCP on TCP_IP version */
           /* e.g. "1.2" = 0x0102 */
     uint; /* PORT */

     taggedunion {
       "HOST_NAME" char[256];
       "ADDRESS" char[15];
       "IPV6" char[39];
     };
     taggedstruct{
       "MAX_BUS_LOAD"  ulong; /* maximum available bus */
				     /* load in percent */
       "MAX_BIT_RATE"  ulong; /* Network speed which is */ 
                              /* the base for MAX_BUS_LOAD in Mbit*/

     };

  };

/************************* end of TCP_IP *******************/


/***********************************************************/
/*                                                         */
/* ASAP2 meta language for XCP on TCP_IP V1.2              */
/*                                                         */
/*                                                         */
/*   Datatypes:                                            */
/*                                                         */
/*   A2ML       description                                */
/*   ----------------------------------------------------- */
/*   uchar      unsigned 8  Bit                            */
/*   char       signed 8 Bit                               */
/*   uint       unsigned integer 16 Bit                    */
/*   int        signed integer 16 Bit                      */
/*   ulong      unsigned integer 32 Bit                    */
/*   long       signed integer 32 Bit                      */
/*   float      float 32 Bit IEEE 745                      */
/*                                                         */
/***********************************************************/
/************************ start of UDP_IP ******************/

  struct UDP_IP_Parameters {

     uint; /* XCP on UDP_IP version */
           /* e.g. "1.2" = 0x0102 */
     uint; /* PORT */

     taggedunion {
       "HOST_NAME" char[256];
       "ADDRESS" char[15];
       "IPV6" char[39];
     };
     taggedstruct{
       "MAX_BUS_LOAD"  ulong; /* maximum available bus */
				     /* load in percent */
       "MAX_BIT_RATE"  ulong; /* Network speed which is */ 
                              /* the base for MAX_BUS_LOAD in Mbit*/

     };

  };

/*************************** end of UDP ********************/


/***********************************************************/
/*                                                         */
/* ASAP2 meta language for XCP on FLX V1.2                 */
/*                                                         */
/*                                                         */
/*   Datatypes:                                            */
/*                                                         */
/*   A2ML       description                                */
/*   ----------------------------------------------------- */
/*   uchar      unsigned 8  Bit                            */
/*   char       signed 8 Bit                               */
/*   uint       unsigned integer 16 Bit                    */
/*   int        signed integer 16 Bit                      */
/*   ulong      unsigned integer 32 Bit                    */
/*   long       signed integer 32 Bit                      */
/*   float      float 32 Bit IEEE 745                      */
/*                                                         */
/***********************************************************/
/************************ start of FLX *********************/
  
  enum packet_assignment_type {
               "NOT_ALLOWED",
               "FIXED",
               "VARIABLE_INITIALISED",
               "VARIABLE"
               }; /* end of packet_assignment_type */
  
  struct buffer {
  
    uchar;  /* FLX_BUF */
   
    taggedstruct {
  
      "MAX_FLX_LEN_BUF" taggedunion {
               "FIXED" uchar;    /* constant value */
               "VARIABLE" uchar; /* initial value */
               }; /* end of MAX_FLX_LEN_BUF */
  
      block "LPDU_ID" taggedstruct {
  
        "FLX_SLOT_ID" taggedunion {
               "FIXED" uint;
               "VARIABLE" taggedstruct{
                   "INITIAL_VALUE" uint;
                   };
               }; /* end of FLX_SLOT_ID */
  
        "OFFSET" taggedunion {
               "FIXED" uchar;
               "VARIABLE" taggedstruct{
                   "INITIAL_VALUE" uchar;
                   };
               }; /* end of OFFSET */
  
        "CYCLE_REPETITION" taggedunion {
               "FIXED" uchar;
               "VARIABLE" taggedstruct{
                   "INITIAL_VALUE" uchar;
                   };
               }; /* end of CYCLE_REPETITION */
  
        "CHANNEL" taggedunion {
               "FIXED" enum {
                        "A" = 0,
                        "B" = 1
                       };
               "VARIABLE" taggedstruct{
                   "INITIAL_VALUE" enum {
                                    "A" = 0,
                                    "B" = 1
                                   };
                   };
               }; /* end of CHANNEL */
  
         }; /* end of LPDU_ID */
  
      block "XCP_PACKET" taggedstruct {
  
        "CMD" enum packet_assignment_type;          /* end of CMD          */
        "RES_ERR" enum packet_assignment_type;  /* end of RES_ERR */
        "EV_SERV" enum packet_assignment_type;  /* end of EV_SERV  */
        "DAQ" enum packet_assignment_type;           /* end of DAQ           */
        "STIM" enum packet_assignment_type;          /* end of STIM          */
       
         }; /* end of XCP_PACKET */
    }; 
  
  }; /* end of buffer */
  
  struct FLX_Parameters {
  
      uint;                              /* XCP on FlexRay version  */
                                           /* e.g. "1.0" = 0x0100 */
  
      uint;                          /* T1_FLX [ms] */
  
      char[256];                     /* FIBEX-file including CHI information */
                                     /* including extension    */
                                     /* without path */
  
      char[256];                     /* Cluster-ID */
  
      uchar;                         /* NAX */
  
      enum { 
        "HEADER_NAX"               = 0,
        "HEADER_NAX_FILL"          = 1,
        "HEADER_NAX_CTR"           = 2,
        "HEADER_NAX_FILL3"         = 3,
        "HEADER_NAX_CTR_FILL2"     = 4,
        "HEADER_NAX_LEN"           = 5,
        "HEADER_NAX_CTR_LEN"       = 6,
        "HEADER_NAX_FILL2_LEN"     = 7,
        "HEADER_NAX_CTR_FILL_LEN"  = 8
      };
   
  
      enum { 
        "PACKET_ALIGNMENT_8"  = 0,
        "PACKET_ALIGNMENT_16" = 1,
        "PACKET_ALIGNMENT_32" = 2
      };
  
      taggedunion {
        block "INITIAL_CMD_BUFFER" struct buffer;
      };
  
      taggedunion {    
        block "INITIAL_RES_ERR_BUFFER" struct buffer;
      };
  
      taggedstruct {
  
        (block "POOL_BUFFER" struct buffer)*;
  
      };
  
  };
  
/************************* end of FLX **********************/


    block "IF_DATA" taggedunion if_data {
/***************************************************************************/
/*                                                                         */
/*   ETAS GmbH                                                             */
/*                                                                         */
/*   ASAP2 Meta Language for ETAS ETK Bypass                               */
/*   assumes ASAP2 V1.31 or higher                                         */
/*                                                                         */
/*                                                                         */
/*   Change History:                                                       */
/*                                                                         */
/*   Version  Date        Author     Modification                          */
/*   ===================================================================   */
/*   V1.0     2001-07-01  ETAS/PAC   Official ETAS Version                 */
/*                                   included in RTIO / Tip-EXP            */
/*                                   Equal to RB/DS V1.0                   */
/*   V1.1     2007-01-16  Wenzel     TP_BLOB version 0x0101                */
/*                                   - added: BYPASS_CONFIGURATION         */
/*                                                                         */
/*   V1.2     2010-04-20  Kreikenbohm TP_BLOB version 0x0102               */
/*                        Wrobel     - added: SOFTWARE_REVISION            */
/*                                   - deleted: old stuff                  */
/*                                                                         */
/*   V1.2.1   2013-04-29  Wrobel     - deleted usage of POSSIBLE_SOURCES   */
/*                                     without any following number        */
/*                                   - fixed some text formatting          */
/*                                                                         */
/***************************************************************************/

"ASAP1B_Bypass" taggedstruct {

  block "TP_BLOB" struct {
    uint;           /* Bypass Version, High Byte: Version                  */
                    /*                 Low Byte : subversion (dec.)        */
    uint;           /* Blob Version,   0x0102                              */
                    /*                 High Byte: Version                  */
                    /*                 Low Byte : subversion (dec.)        */
    taggedstruct {
      "BYPASS_CONFIGURATION" struct {
        uint;                    /* BASE_OFFSET_VALUE                      */
                                 /*   value: (0/2) valid for Distab 12     */
                                 /*   value: (0/8) valid for Distab 13     */
                                 /* Allows to define the Bypass Settings   */
                                 /* used in the bypass tool.               */
        taggedstruct {
          "FAR_ADDRESS" struct {
            ulong;               /* FAR_ADDRESS_BEGIN                      */
                                 /*   address value                        */
            ulong;               /* FAR_ADDRESS_LENGTH                     */
                                 /*   size value                           */
          };
          "ADDRESS_MAPPING" enum {
                                 /* [Mask16Bit, DPP0, DPP1, DPP2, DPP3]    */
                                 /* Distab12 only! Ignored for Distab 13ff.*/
            "Mask16Bit" =0,
            "DPP0"      =1,
            "DPP1"      =2,
            "DPP2"      =3,
            "DPP3"      =4
          };
          "SOFTWARE_REVISION" struct {
                                 /* Defines the expected software revision, used for the bypass consistency check. */
                                 /* Different software versions must have different strings here.                  */
                                 /* Optional; if defined it is taken prior to the EPK value by bypass systems.     */
            ulong;               /* SOFTWARE_REVISION_ADDRESS              */
                                 /* start address of the subsequent string */
            char[256];           /* SOFTWARE_REVISION_VALUE                */
                                 /* the software revision as ASCII string  */
          };
        };
      };
    };
  };

  block "KP_BLOB" struct {
    taggedstruct {

      "BUFFER_OFFSET"    char[256];  /* parameter value represents         */
                                     /* Offset value for transfer of       */
                                     /* Stimuli Value from the             */
                                     /* Data buffer into the ECU code      */
                                     /* Can be used in the ECU code        */
                                     /* also as a switch                   */
                                     /* for bypassed / not bypassed        */
                                     /* if the base offset value           */
                                     /* is not equal zero.                 */
                                     /* Base Offset != 0                   */
                                     /* Then  = 0 -> not bypassed          */
                                     /*      != 0 -> bypassed              */

      "SOURCE_ID"        char[256];  /* parameter value represents         */
                                     /* stimulus channel                   */

      "BIT_OFFSET"       char[256];  /* parameter value represents         */
                                     /* mask in case of bit objects        */

      "POSSIBLE_SOURCES" ( uint )*;  /* list of all channels, where this   */
                                     /* intervention point is usable.      */
                                     /* at least one number has to be given*/
                   /* special case:                                        */
                   /* keyword omitted = intervention point is usable       */
                   /*                   in all available channels          */
    };
  };

};  
/*********************************************************************************/
/*                                                                               */
/*   ASAP2 Meta description for ETK/XETK                                         */
/*                                                                               */
/*   Used data types:                                                            */
/*                                                                               */
/*   A2ML       ASAP2          Windows  Explanation                              */
/*   ---------------------------------------------------------                   */
/*   uchar      UBYTE          BYTE     unsigned 8 Bit                           */
/*   char       SBYTE          char     signed 8 Bit                             */
/*   uint       UWORD          WORD     unsigned integer 16 Bit                  */
/*   int        SWORD          int      signed integer 16 Bit                    */
/*   ulong      ULONG          DWORD    unsigned integer 32 Bit                  */
/*   long       SLONG          LONG     signed integer 32 Bit                    */
/*   float      FLOAT32_IEEE            float 32 Bit                             */
/*                                                                               */
/*                                                                               */
/*   AML Version V1.0, 2008                                                      */
/*                                                                               */
/*   Change History:                                                             */
/*                                                                               */
/*   Version  Date           Author          Modification                        */
/*   ========================================================================    */
/*   V1.0.1   26-Oct-2007    ETAS-PHW        Added Advanced Code Check           */
/*                                           parameters                          */
/*   V1.0.2   28-May-2008    ETAS-PSW        ASAP1B_Bypass removed               */
/*   V1.1.0   16-Dec-2008    ETAS-PHW        Added global version to device list */
/*                                           Added display names to device list  */
/*                                           Removed TP_BLOB version             */
/*                                           Removed QP_BLOB version             */
/*                                           Added Trace Windows and Triggers    */
/*   V1.2.0   26-Nov-2010    ETAS-NE         Added Accumulated measurement       */
/*                                           - flag "DISTAB_COLLECTION_MODE"     */
/*                                             for display table in TP-Blob      */
/*                                           - new block "ACCUMULATION_MODE" in  */
/*                                             QP_BLOB with parameters for       */
/*                                             accumulated measurement           */
/*                                           Added Stimulation Raster Support    */
/*                                           Added One-Shot-Measurement Support  */
/*   V1.3.0   03-Nov-2011    ETAS-NE         ETK_XETK_LIST - ETK:                */
/*                                           - add CONFIG features.              */
/*                                           - either ETK_CFG or CONFIG feature  */
/*                                             shall be defined.                 */
/*   V2.0     13-Apr-2012    ETAS-NE         Add project identification:         */
/*                                              - PROJECT_IDENTIFICATION         */
/*                                           Add data freeze definitions:        */
/*                                             - reserved memory segments:       */
/*                                               WRITE_AT_DATA_UPDATE            */
/*                                               USE_FLASH, USE_ECU_FLASH, ERASE */
/*                                             - TP_BLOB: DATA_FREEZE            */
/*                                           Add DISTAB17 definitions in TP_BLOB:*/
/*                                             - ECU_EVENT_LIST                  */
/*                                             - TABLE_ALIGNMENT                 */
/*                                             - EVENT_CONFIG_OUTPUT_AREA        */
/*                                             - DATA_ACQUISITION                */
/*                                             - ECU_PROPERTY                    */
/*                                             - TRIGGER_CFG                     */
/*                                           Change QP_BLOB according DISTAB17:  */
/*                                             - renaming: raster -> event       */
/*                                             - add ECU_PROPERTY                */
/*                                           Allow only one block TIMER_CFG      */
/*                                           Allow ETK specific TRACE_TRIGGER_CFG*/
/*                                           Add / change page switching:        */
/*                                             - add OMD page switch: OMD        */
/*                                           Add user specific error code text:  */
/*                                             - ECU_DEFINED_ERRORCODES          */
/*********************************************************************************/

/*********************************************************************************/
/*                                                                               */
/* For a correct working of the (X)ETK, the following MEMORY_SEGMENTs            */
/* have to  be specified in the section 'MOD_PAR' of the ASAP2 file:             */
/*                                                                               */
/*  /begin MEMORY_SEGMENT                                                        */
/*     Dataxxxx ""  DATA FLASH <mem. location> <address> <size> <mirrors>        */
/*  /end MEMORY_SEGMENT                                                          */
/*                                                                               */
/*  /begin MEMORY_SEGMENT                                                        */
/*     Codexxxx ""  CODE FLASH <mem. location> <address> <size> <mirrors>        */
/*  /end MEMORY_SEGMENT                                                          */
/*                                                                               */
/*  /begin MEMORY_SEGMENT                                                        */
/*     ExRAM "ExRAM for DISTAB" VARIABLES RAM EXTERN <address><size><mirrors>    */
/*  /end MEMORY_SEGMENT                                                          */
/*                                                                               */
/*********************************************************************************/

  "ETK_XETK" struct
  {
    taggedstruct 
    {
      block "ETK_XETK_LIST" struct 
      {
        /* defines the version of the used AML */
        enum 
        {
          "ETK_XETK_AML_VERSION_2_0_0" = 0x020000
        };
        
        taggedstruct 
        {        
          "PROJECT_IDENTIFICATION" char[256];

                                /* The ETK_XETK_ID is used as reference (ETK_XETK_REF)*/
                                /* by other IF_DATA XETK feature descriptions.        */
                                /* Therefor it must be unique within ETK and XETK.    */
                                /* It is intended that numbers beginning with "1"     */
                                /* are used. The "0" is reserved for future use.      */
          (block "ETK"  struct
          {
            ulong;                /* ETK_XETK_ID         the unique identifier        */
            enum                  /* DEVICE_COMM_SPEED   fix comm speed on ETK line   */ 
            {                     /*                     to 8/100 MBit/s              */                                  
              "INTERFACE_SPEED_8MBIT"   = 1,
              "INTERFACE_SPEED_100MBIT" = 2
            };

            taggedstruct 
            {
              "ETK_CFG" (uchar)*; /* config string for existing ETKs                   */

              ("CONFIG" struct
              {
                char[256];        /* DEVICE_PARAM        parameter                     */
                char[256];        /* DEVICE_PARAM_VALUE  value                         */
              })*;
              
              "RESET_CFG" ulong;  /* reset config word. not used for serial ETKs       */
              "DISPLAY_NAME" char[256]; /* name for display */
            };
          })*;

          (block "XETK" struct
          {
            ulong;                /* ETK_XETK_ID  the unique identifier                */
            taggedstruct 
            {
              ("CONFIG" struct
              {
                char[256];        /* DEVICE_PARAM        parameter                     */
                char[256];        /* DEVICE_PARAM_VALUE  value                         */
              })*;
              "DISPLAY_NAME" char[256]; /* name for display */
            };
          })*;
        
          block "RASTER_CHECK" struct 
          {
            taggedstruct 
            {
              "OFFLINE_DEVICE" ulong; /* default device used for offline raster check, displayed in INCA HWC*/
            };
            enum /* default for online raster check */ 
            {  
              "ONLINE_RESPECT_OFFLINE_LIMIT" = 1,
              "ONLINE_USE_CONNECTED_DEVICE_ONLY" = 2
            };
          };
        };
      };
      
      /* Description of an address mapping between addresses in the view of the */
      /* EPROM of the ECU (and ASAP2) and the addresses in the scope of the ETK */
      /* IF_DATA section used with MEMORY_SEGMENT (can be missing if no         */
      /* differences between the 2 views)                                       */

      ("ADDRESS_MAPPING" struct
      {
        ulong;              /* Start address of MEMORY_SEGMENT */
        ulong;              /* mapped start address for ETK    */
        ulong;              /* Length of mapped address range  */
        taggedstruct
        {
          "ETK_XETK_REF" (ulong)*; /* references to used ETKs  */
        };
      })*;
      
      /* IF_DATA section used with MEMORY_SEGMENT                             */
      /* defines whether the memory is located (emulated) in the XETK or      */
      /* or whether the XETK accesses the memory via serial interface, e.g.   */
      /* debug interface                                                      */
      (block "ETK_XETK_ACCESS" struct
      {
        taggedunion
        {
          "NOT_RELEVANT_FOR_ETK_XETK";      /* do not touch the segment                    */
          "ETK_XETK_EMULATION_MEMORY";      /* XETK DPR, memory is located in XETK         */
          "SERIAL_INTERFACE" struct         /* e.g. debug interface, memory located in ECU */
          {
            taggedstruct 
            {
              "PHYSICAL_ADDRESS" ulong;
            };
          };
        };
        taggedstruct
        {
          "ETK_XETK_REF" (ulong)*; /* references to used ETKs  */
        };
      })*;
      
      /* IF_DATA section used with RESERVED MEMORY_SEGMENT to control data freeze */
	  "WRITE_AT_DATA_UPDATE" struct 
	  {
        enum 
        {
          "USE_FILE" = 0,
          "USE_ECU_FLASH" = 1,
          "ERASE" = 2
        };
	  };	/* if set, the segment shall be freezed while data freeze */
      "ETK_XETK_REF" (ulong)*; /* references to used ETKs         */
      
      /* description of the trace window */
      (block "TRACE_WINDOW" struct
      {
        ulong;      /* START_ADDRESS  start address of the trace window */
        ulong;      /* SIZE           size of the trace window          */
        taggedstruct 
        {
          "PHYSICAL_ADDRESS" ulong;
        };
        taggedstruct {
          ("CONFIG" struct
          {
            char[256];        /* TRACE_PARAM        parameter           */
            char[256];        /* TRACE_PARAM_VALUE  value               */
          })*;
        };
      })*;


      "DEFAULT_RASTERS" (ulong)*; /* used in MEASUREMENT definitions; refers  */
                                  /* to the RSTR_ID field of the QP_BLOB      */

      block "TP_BLOB" struct
      {
        enum                   /* BYTE_ORDER */
        {
          "BYTE_ORDER_MSB_FIRST" = 1,
          "BYTE_ORDER_MSB_LAST" = 2
        };

        taggedstruct {
          block "DISTAB_CFG" struct 
          {
            uint;             /* DISTAB_NBR        distab version */
            taggedstruct 
            {
              "DISTAB_12_DAT_MOD" enum 
              {
                "DAT_MOD_BYTE" = 1,
                "DAT_MOD_WORD" = 2
              };
            };
            taggedstruct 
            {
              "DISTAB_COLLECTION_VERSION" enum 
              { /* Main switch: accumulated measurement parameter in QP-BLOB allowed  */
                "STANDARD" = 0,              /* default value,if mising               */
                "ACCUMULATED_VERSION_1" = 1  /* Distab header defined for version 1   */
              };
            };
          };
          
          (block "ECU_EVENT_LIST" struct
          {
            ulong; /* start address of ECU event list        */
            taggedstruct  
            {    
              "ETK_XETK_REF" (ulong)*; 
            };
          })*;
          
		  "TABLE_ALIGNMENT" enum { /* alignment of event config and data area */
			"ALIGNMENT_2_BYTE" = 2,
			"ALIGNMENT_4_BYTE" = 4,
			"ALIGNMENT_8_BYTE" = 8,
			"ALIGNMENT_16_BYTE" = 16
		  };
          
          (block "EVENT_CONFIG_OUTPUT_AREA" struct
          {
            ulong; /* start of event config area */
            ulong; /* size in bytes of event config area */
            ulong; /* start of event output area */
            ulong; /* size in bytes of event output area */
            taggedstruct
            {
              "ETK_XETK_REF" (ulong)*; /* references to used ETKs            */  
            };
          })*;

          (block "DATA_ACQUISITION" struct
          {
            taggedstruct
            {
              ("PRIORITY_RANGE" struct 
              {
                ulong;  /* first priority */
                ulong;  /* last priority */
              })*;
              "ETK_XETK_REF" (ulong)*; /* references to used ETKs            */  
            };
          })*;
          
          (block "ECU_PROPERTY" struct {
            taggedstruct 
            {
              "OVERALL_PERFORMANCE" struct
              {
                ulong;       /* overall variables per second */
                ulong;       /* overall bytes per second     */
              };
              ("CORE_PERFORMANCE" struct
              {
                ulong;     /* core                       */
                ulong;     /* variables per second       */
                ulong;     /* bytes per second           */
              })*;
              "ETK_XETK_REF" (ulong)*; /* references to used ETKs */  
            };
          })*;
          
          /* List of triggers provided by the ECU for services */
          (block "TRIGGER_CFG" struct 
          {
            taggedstruct
            {
              ("TRIGGER" struct
              {
                ulong;        /* TRG_NBR: the number of the hardware trigger */
                taggedunion { /* TRG_TYPE: trigger type */
                  "DIRECT";
                  "INDIRECT";                  
                };
                taggedstruct {
                  "ECU_ID" struct {
                    uint; /* ECU_ID, to be written in trigger of the event configuration */
                  };
                };
              })*;
              "ETK_XETK_REF" (ulong)*; /* references to used ETKs            */  
            };
          })*;
		  
          block "TIMER_CFG" struct
          {
            /* Description of Timers used for triggering  */

            taggedstruct
            {
              ("TIMER" struct {
                uint;            /* TIMER_ID          Timer number (start with 1) */
                ulong;           /* TIMER_TIME        Time in us                  */
              })*;
            };
          };

          (block "TRACE_TRIGGER_CFG" struct
          {          
            taggedstruct 
            {
              ("TRACE_TRIGGER" struct 
              {
                /* Description of Trace trigger                                                       */               
                uint;               /* TRACE_TRIGGER_ID  Trace Trigger number (start with 1)          */
                ulong;              /* ADDRESS           Address of write access to raise the trigger */
                taggedstruct 
                {
                  ("CONFIG" struct
                  {
                    char[256];        /* TRACE_TRIGGER_PARAM        parameter   */
                    char[256];        /* TRACE_TRIGGER_PARAM_VALUE  value       */
                  })*;
                };
              })*;
              "ETK_XETK_REF" (ulong)*; /* references to used ETKs               */  
            };
          })*;

          (block "RESERVED_MEMORY" struct
          {
            /* Description of 'reserved ranges' (especially in the data or code   */
            /* ranges; e.g. location of the display tables) that are excluded     */
            /* from checksum verification. If the 3 display tables stand close    */
            /* together, the size of the reserved memory is calculated by the     */
            /* following formula:                                                 */
            /*          size = (highest start address of the 3 distabs)           */
            /*                  + ((size of this distab) + 2) * 4                 */
            /*                  - (lowest start address of the 3 distabs)         */

            ulong;           /* RES_MEM_ADDR       Start address                  */
            ulong;           /* RES_MEM_LEN        Length in bytes                */
            enum {           /* RES_MEM_LOCATION   Location                       */
              "INTERN"  = 0,
              "EXTERN"  = 1
            };
            enum {           /* RES_MEM_APPL       application                    */
              "MEASUREMENT" = 0,
              "BYPASS"    = 1
            };
            enum {           /* RES_MEM_USAGE      usage                          */
              "CHECKSUM_EXCLUDE_ONLY" = 0,
              "ECU_DISTAB_INPUT"      = 1,
              "ECU_DISTAB_OUTPUT"     = 2,
              "ECU_DISTAB_INOUT"      = 3
            };
            taggedstruct
            {
              "ETK_XETK_REF" (ulong)*; /* references to used ETKs                 */
            };
          })*;

          (block "MAILBOX" struct
          {
            /* Description of the ETK mailbox that is used for communication      */
            /* between the ECU and the application program (e.g. for programming  */
            /* data into the ECU flash)                                           */

            ulong;           /* ETK_MBX_TEST_PATTERN  Test pattern for the ECU to    */
                             /*                       detect a valid mailbox         */
            enum {           /* ETK_MBX_IN_MEM_PAGE   Memory page (code, data,       */
                             /*                       external RAM) used for         */
                             /*                       communication from application */
                             /*                       program to ECU                 */
              "CODE"  = 1,
              "DATA"  = 2,
              "RAM" = 3
            };
            ulong;           /* ETK_MBX_IN_BUF_ADDR   Base address of buffer for       */
                             /*                       communication application -> ECU */
            ulong;           /* ETK_MBX_IN_BUF_LEN    Length of buffer for             */
                             /*                       communication application -> ECU */
            enum {           /* ETK_MBX_OUT_MEM_PAGE  Memory page (code, data,         */
                             /*                       external RAM) used for           */
                             /*                       communication ECU -> application */
              "CODE"  = 1,
              "DATA"  = 2,
              "RAM" = 3
            };
            ulong;           /* ETK_MBX_OUT_BUF_ADDR  Base address of buffer for       */
                             /*                       communication ECU -> application */
            ulong;           /* ETK_MBX_OUT_BUF_LEN   Length of buffer for             */
                             /*                       communication ECU -> application */
            ulong;           /* ETK_MBX_TYPE          Mailbox type                     */

            enum {           /* ETK_MBX_VERSION       Mailbox version                  */
              "MB_VERSION_1_0" = 0x100
            };
            taggedstruct {               /*     references to used ETKs       */
              "ETK_XETK_REF" (ulong)*;   /*     ref to ETK_XETK_ID            */
            };
          })*;

          block "TRIGGER_SEGMENT_BASE" struct 
          {
            ulong;           /* TRGSEGAD      Trigger segment address */
            taggedstruct
            {
              "ETK_XETK_REF" (ulong)*; /* references to used ETKs     */
            };
          };

          block "CODE_CHK" struct {
            /* A check, whether program and data are matching can be performed,   */
            /* if the ECU copies a certain 'program identifier' (e.g. the code    */
            /* checksum) into the external RAM and the same identifier is stored  */
            /* in the data range. The ETK driver can read and compare both        */
            /* identifier and issue an error message, if the both identifiers do  */
            /*  not match.                                                        */

            ulong;           /* CDE_CHK_INT_ADDR   ETK: address of program        */
                             /*                    identifier in the data         */
                             /*                    range PRG_DATA                 */
            ulong;           /* CDE_CHK_EXT_ADDR   ETK: address of program        */
                             /*                    identifier in the              */
                             /*                    external RAM PRG_ERAM          */
            uint;            /* CDE_CHK_LEN        ETK: length of program         */
                             /*                    identifier in the data         */
                             /*                    range (max. 32 bytes)          */
            taggedstruct
            {
              "PATTERN_REFRESH_TIMEOUT" struct 
              {
                uint;          /* CDE_CHK_TIM timeout in ms                       */
              };
            };
            /* If all parameters contain 0x0 values, no check is performed        */

            taggedstruct 
            {
                "ERROR_BEHAVIOR" enum {     /* reaction of MC tool to ECU when    */
                "PERMANENT_RESET" = 0,      /* code check fails                   */
                "NO_RESET"        = 1
              };

              "ETK_XETK_REF" (ulong)*; /* references to used ETKs                 */
            };
          };

          (block "PRESENCE_PATTERN" struct 
          {
            ulong;           /* address of ETK recognition pattern        */
            taggedstruct
            {
              "PATTERN" (uchar)*;      /* bytes used for presence check   */
              "ETK_XETK_REF" (ulong)*; /* references to used ETKs         */
            };
          })*;

          block "COLDSTART_HANDSHAKE" struct
          {
            ulong;           /* COLDSTART_PATTERN_ADDR  address of ETKS cold    */
                             /*                         start pattern           */
            taggedstruct {
              "WAIT" (uchar)*;   /* pattern                                     */

              "READY" (uchar)*;  /* pattern                                     */

              "ETK_XETK_REF" (ulong)*; /* references to used ETKs               */
            };
          };

          block "PAGE_SWITCH_METHOD" struct 
          {
            ulong;               /* Page Switch Method version                    */
            taggedstruct {
              "MAILBOX" struct {
                ulong;           /* MBX_VERSION          Version of mailbox       */
                ulong;           /* MBX_PAGE_SETUP_TIME  max time the ECU needs   */
                                 /*                      to set up page in ms     */
                ulong;           /* MBX_ADDR             Start address of table   */
              };
  
              "AUTOSTART_BEHAVIOR" enum {
                "LAST_ACTIVE_PAGE" = 0, /* Table to be filled by INCA with info */
                                        /* for the current active page          */
                "ALWAYS_WP"        = 1, /* Request field to be filled by INCA   */
                                        /* always with info for working page    */
                "ALWAYS_RP"        = 2  /* Request field to be filled by INCA   */
                                        /* always with info for reference page  */
              };
  
              "OCT_WORKINGPAGE" struct {
                ulong;       /* OCT_TYPE         Type of table                  */
                ulong;       /* OCT_ADDR         Start address of table         */
                ulong;       /* OCT_LEN          max Length of table in byte    */
              };
  
              "OCT_REFERENCEPAGE" struct {
                ulong;       /* OCT_TYPE         Type of table                  */
                ulong;       /* OCT_ADDR         Start address of table         */
                ulong;       /* OCT_LEN          max Length of table in byte    */
              };
              
              "OMD" struct {
                ulong;       /* OMD_ADDRESS                 Address of OMD                               */
                ulong;       /* OMD_CID                     CID of OMD                                   */
                ulong;       /* OMD_VERSION                 Version of OMD table                         */
                ulong;       /* OMD_MAX_LEN                 Max. length of OMD in bytes                  */
                ulong;       /* OMD_NUMBER_OF_EMU_HANDLES   Number of EMU handles in table.              */
                             /*                             Value should match with the uC capabilities. */
              };

              "CODE_CHK_PATTERN_WP" struct {
                ulong;     /* CDE_CHK_WP_ADDR  address of code check pattern in working page */
              };

              "ETK_XETK_REF" (ulong)*; /* references to used ETKs */
            };
          };
          
          block "ECU_DEFINED_ERRORCODES" struct 
          {
            taggedstruct {
              ("ERROR_ENTRY" struct {
              ulong;                /* Error code; must be unique!                                 */
              char[256];            /* Error message used by INCA for the code previously defined. */
              })*;
            };
          };


          block "CAL_WAKEUP" taggedstruct 
          {
            "CAL_WAKEUP_PIN" ulong;     /* 1 = wake up enabled, 0 = disabled  */
            "CAL_TOOL_PRESENT" struct {
              ulong;               /* CAL_TOOL_PATTERN_ADDR    address for the pattern        */
              ulong;               /* CAL_TOOL_PATTERN         pattern                        */
              ulong;               /* CAL_TOOL_ECU_TIMEOUT     ECU timeout for shut down in s */
            };
            "ETK_XETK_REF" (ulong)*;
          };
        
          (block "DATA_FREEZE" taggedstruct
          {
            ("CONFIG" struct {
              char[256]; /* DATA freeze config feature parameter   */
              char[256]; /* DATA freeze config feature value       */
            })*;
            "ETK_XETK_REF" (ulong)*;
          })*; 
        
        };
      };

      (block "SOURCE" struct
      {
        /* Description of the acquisition (trigger) levels supplied by the ECU  */

        struct  
        {
          char [100];        /* Source name                                     */
          int;               /* CSE unit according to Asap1b (minimal period    */
                             /* duration) of the acqisition raster              */
          long;              /* Minimal period number measured in the CSE unit  */
        };
        taggedstruct
        {
          block "QP_BLOB" struct
          {
            uint;  /* RSTR_ID         unique id. Is referred to in the measurement sections       */
            uint;  /* RSTR_PRIO       event priority, higher number = higher priority             */
            ulong; /* RSTR_MIN_TIME   worst case minimum raster time in us, 0 is not considered in the raster check */
            taggedstruct {
              (block "ETK_XETK_SPECIFIC" struct
              {
                taggedunion {            /* TRG_GEN raster trigger generation                     */
                  "TRG_NBR" struct 
                  {
                    uint;                /* hardware trigger number                               */
                  };
                  "TIMER_REF" struct 
                  {
                    uint;                /* TIMER_REF         reference to TIMER_ID               */
                  };
                  "TRACE_TRIGGER_REF" struct
                  {
                    uint;                /* TRACE_TRIGGER_REF reference to trace TRACE_TRIGGER_ID */
                  };
                  "STIM_EVENT" struct
                  {
                    uint;                /* STIM_EVENT the "event" for the stimulation action */
                  };
                  "START_MEASUREMENT_EVENT" struct
                  {
                    uint;                /* the "event" generated at the start of the measurement */
                  };
                  
                };
                taggedunion {            /* TRG_TYPE          trigger type                   */
                  "DIRECT";
                  "INDIRECT" struct{
                    ulong;               /* TRG_FLG_ADDR      Flag for indirect trigger      */
                  };                  
                };
                
                taggedstruct 
                { /* definition for Accumulation mode; */
                  block "ACCUMULATION_MODE" struct 
                  {
                    uint;  /* SUB_SAMPLES no. of samples to be collected  */
                           /* before trigger to ETK is generated          */
                    taggedstruct 
                    {
                      /* Measurement Variable size restrictions.                        */ 
                      /* If missing ECU supports all  for accumulated measurement.      */
                      /* Can be used multiple times to exclude different variable sizes */
                      ("DATA_TYPE_RESTRICTION" enum 
                      {  
                        "NO_BYTES"   = 1,  /* no byte values allowed   */
                        "NO_2BYTES"  = 2,  /* no 2 byte values allowed */
                        "NO_4BYTES"  = 3,  /* no 4 byte values allowed */
                        "NO_8BYTES"  = 4   /* no 8 byte values allowed */
                      })*;

                      /* Method for alignment of sub sample entries */
                      "SUB_SAMPLE_BUFFER_ALIGNMENT" enum 
                      {
                        "_2BYTES" = 1,  /* 2 bytes */
                        "_4BYTES" = 2,  /* 4 bytes */
                        "_8BYTES" = 3   /* 8 bytes */
                      };
                    };
                  };
                };

                taggedstruct {
                  block "DISTAB_LAYOUT" struct {
                    ulong;                   /* DSPL_ADDRTBL_ADDR address of display address     */
                                             /*                   table                          */
                    uint;                    /* DSPL_ADDRTBL_MAX  maximum number of variables    */
                                             /*                   in display address table       */
                    ulong;                   /* DSPL_OUTTBL_ADDR  address of display output      */
                                             /*                   table                          */
                    uint;                    /* DSPL_OUTTBL_LEN   maximum size of display output */
                                             /*                   table in bytes                 */
                  };

                  block "BYPASS_LAYOUT" struct {
                    ulong;               /* BYPS_OUTTBL_ADDR  address of the bypass output   */
                                         /*                   table                          */
                    ulong;               /* BYPS_OUTTBL_LEN   maximum size of bypass output  */
                                         /*                   table in byte                  */
                  };
                  
                  "ETK_XETK_REF" (ulong)*; /* references to used ETKs                        */

                  /* special entries to make this raster usable for 3rd party tools:       */

                  "RESERVED_RASTER_DISTAB_SETUP_XETK";  /* INCA configures the XETK raster */
                                                        /* for use with 3rd party tool     */
                                                        /* XETK sets up DISTAB             */
                  "RESERVED_RASTER_DISTAB_IGNORE_XETK"; /* INCA configures the XETK raster */
                                                        /* for use with 3rd party tool     */
                                                        /* XETK ignores DISTAB             */
                                                        /* (does not setup DISTAB)         */
                };
                
                taggedstruct {
                  block "ECU_PROPERTY" struct {
                    taggedstruct {
                      "PERFORMANCE" struct
                      {
                        ulong;     /* core                       */
                        ulong;     /* variables per second       */
                        ulong;     /* bytes per second           */
                      };
                      "NOT_ALLOWED_8_BITS";  /* 8 bit variables are not allowed               */
                      "NOT_ALLOWED_16_BITS"; /* 16 bit variables are not allowed              */
                      "NOT_ALLOWED_32_BITS"; /* 32 bit variables are not allowed              */
                      "NOT_ALLOWED_64_BITS"; /* 64 bit variables are not allowed              */
                    };
                  };
                };
              })*;
            };
          };
        };
      })*;
    };
  };
/*******************************************************************************************/
/*                                                                                         */
/*   ASAP2 Meta description for Service Based Bypass                                       */
/*   ETAS GmbH                                                                             */
/*                                                                                         */
/*  History                                                                                */
/*  -------                                                                                */
/*  10.11.2008 Kgr (V1.0.0) first released version                                         */
/*                                                                                         */
/*  06.03.2009 Wb  (V2.0.0) provide separate array for enable / disable function execution */
/*                          this version is not compatible with version 1.0.0!             */
/*                                                                                         */
/*  22.01.2010 Wb  (V3.0.0) provide the Execution Clustering mechanism                     */
/*                          to reduce the resource consumption                             */
/*  06.05.2010 Wb           changed from EXECUTION_CLUSTER to SP_CLUSTER                   */
/*                          and SP_CLUSTER_GROUP                                           */
/*  25.08.2010 Wb           added IMPLEMENTED_SBB_VERSIONS block                           */
/*                          to separate AML and SBB version                                */
/*  26.08.2010 Wb           removed erroneous SERVICE_AML_VERSION_2_0_0 enum entry         */
/*                                                                                         */
/*  12.04.2012 Wb  (V3.1.0) replaced TRIGGER_ETK by DISTAB 17 compatible                   */
/*                              DATA_ACQUISITION and TRIGGER_CFG definitions               */
/*                          added optional HOOKED attribute to SERVICE_POINT definition    */
/*                                                                                         */
/*******************************************************************************************/

"SERVICE_BASED_BYPASS" struct {

    taggedstruct {
        block "SERVICES" struct {
            enum { /* current ServiceAmlVersion */
                "SERVICE_AML_VERSION_3_1_0" = 30100
            };
            uchar;     /* BaseOffsetValue: added to the Hooked Service Point and Hooked Based Bypass signal's Offset Label Value */
                       /* 0 and 8 supported for DISTAB 13 and 16 */
                       /* 0 and 4 is supported for DISTAB 17 */
                       /* This entry will be removed in a future AML version. */
                       /* Please use BASE_OFFSET_VALUE definition in the ASAP1B_Bypass AML instead. */
            uint;      /* NumSrvPts: number of implemented Service Points */
            char[256]; /* SrvPtResId: name of the CHARACTERISTIC array */
                       /* where the resource Id incremented by 1 for each service point is stored. */
                       /* The number of the service point serves as index into this array. */
            char[256]; /* SrvPtEnabled: name of the Characteristic array which holds the enable flag for all used Service Points */
                       /* The resource ID of the service point serves as index into this array. */
            char[256]; /* TimeOutMaxPre: name of the Characteristic array which holds the maximum time out value for all used Service Points' pre-raster */
                       /* The resource ID of the service point serves as index into this array. */
            char[256]; /* TimeOutMaxPost: name of the Characteristic array which holds the maximum time out value for all used Service Points' post-raster */
                       /* The resource ID of the service point serves as index into this array. */
            enum {     /* DblBufUsed: does the DisTab utilize double buffer scheme, which may not be required */
                "DOUBLE_BUFFERING_NOT_USED" = 0x0,
                "DOUBLE_BUFFERING_USED" = 0x1       /* this is currently the only supported value */
            };
            char[256]; /* DisableFctExec: name of the CHARACTERISTIC array */
                       /* where the flag for disabling the execution of the original function of the Service Point is defined. */
                       /* The number of the service point serves as index into this array. */
            taggedstruct {
                block "IMPLEMENTED_SBB_VERSIONS" taggedstruct  {
                    /* Select the subset of SBB versions, which the ECU implements. It is mandatory to define at least one version. */
                    "SBB_V2_0"; /* supported with DISTAB 13/16 */
                    "SBB_V3_0"; /* supported with DISTAB 13/16 */
                    "SBB_V3_1"; /* supported with DISTAB 17 */
                };
            };

            taggedstruct {
                "RESOURCE_IDS_SERVICE_POINT" char[256]; /* ResIdSrvPt: optional name of the CHARACTERISTIC array */
            };                                          /* where the service point number for each */
                                                        /* resource ID is stored. This is the reverse table of SERVICE_POINTS_RESOURCE_ID */
                                                        /* and serves as lookup table for Measurement&Calibration applications. */

            taggedstruct { /* List of service points provided by the ECU */
                (block "SERVICE_POINT" struct {
                    int;                                /* Number: Service Point's number; counted from 1 */
                    char[256];                          /* Name: Service Point's name */
                    taggedstruct {
                        "PRIORITY" uint;                /* service point priority: a number 0..0xFFFF defining the priority of this service point to be taken into account when assigning trigger ressources. The higher the number, the higher the priority. High priority service point will be triggered by high priority triggers. */
                        "SP_CLUSTER" uint;              /* service point cluster: all service points with the same number here are assumed to be executed with the same priority in the ECU and with other priority than all other service points. This enables automatic optimizations allocating resources to this service point. */
                                                        /* number range 0..0xFFFF */
                        "SP_CLUSTER_GROUP" uint;        /* service point cluster group: all service points with the same number here are assumed to be executed concurrently in the ECU and all other service points can not interfere with these from this group. This enables automatic optimizations allocating resources to this service point. */
                                                        /* number range 0..0xFFFF */
                        "HOOKED";                       /* If defined, the ECU has implemented hooked MEASUREMENTs for this service point. */
                                                        /* Can be used from SBB_V3_1 on. */
                    };
                })*;
            };

            taggedstruct { /* Future versions may also provide SBB_PRECONFIGURED_STRUCTURE; it is possible, that an ECU implements multiple modes. */
                "SBB_DYNAMIC_STRUCTURE" struct {								
                    uint;       /* SBBDynStrucVer: SBB dynamic structure version is independent from SERVICE_VERSION_X_Y */
                                /* with DISTAB 13/16 only version 1 is supported */
                                /* with DISTAB 17 only version 2 is supported */
                    ulong;      /* ResWorkArea: resource working area address, where resource blocks and address and data tables are allocated. Located e.g. in ETK FLASH for all ETK types  */
                    ulong;      /* ResWorkAreaLength: length of the resource working area in bytes */
                    ulong;      /* EcuWrtblResWorkArea: where RAM resource blocks and data tables are allocated. Located e.g. in ETK RAM for parallel ETKs and ECU RAM for serial ETKs */
                    ulong;      /* EcuWrtblResWorkAreaLength: length of the ECU writable resource working area in bytes */

                    /* List of triggers provided by the ECU for services */
                    taggedunion {
                        /* this variant has to be used for DISTAB 13, i.e. SBB V2 and V3.0 */
                        block "TRIGGER_COMBINED_WITH_CHANNEL" taggedstruct {
                            (block "TRIGGER_ETK" struct {
                                uint;         /* TRG_NBR: the number of the hardware trigger (1..32) */
                                uint;         /* RSTR_PRIO: raster priority (1..32), higher number = higher priority */
                                taggedunion { /* TRG_TYPE: trigger type */
                                    "DIRECT";
                                    "INDIRECT";
                                };
                                taggedstruct {
                                  "ETK_XETK_REF" (ulong)*; /* reference to ETKs if used together with an ETK_XETK AML*/
                                };
                            })*;
                        };

                        /* this variant has to be used from DISTAB 17 on, i.e. from SBB V3.1 on */
                        block "TRIGGER_SEPARATED_FROM_CHANNEL" taggedstruct {
                            (block "TRIGGER_CFG" struct {
                                taggedstruct {
                                    ("TRIGGER" struct {
                                        ulong;        /* TRG_NBR: the number of the hardware trigger (1..32) */
                                        taggedunion { /* TRG_TYPE: trigger type */
                                            "DIRECT";
                                            "INDIRECT";
                                        };
                                        taggedstruct {
                                            "ECU_ID" struct {
                                                uint; /* ECU_ID, optional, to be used to define the trigger for the ECU driver (0..0xFFFF) */
                                            };
                                        };
                                    })*;
                                    "ETK_XETK_REF" (ulong)*; /* references to used ETKs if used together with an ETK_XETK AML */  
                                };
                            })*;

                            /* List of data acquisition channels provided by the ECU for services */
                            (block "DATA_ACQUISITION" struct {
                                taggedstruct {
                                    ("PRIORITY_RANGE" struct {
                                        ulong;  /* first priority (1..32), higher number = higher priority */
                                        ulong;  /* last priority  (1..32), higher number = higher priority */
                                                /* first priority <= last priority                         */
                                    })*;
                                    "ETK_XETK_REF" (ulong)*; /* references to used ETKs if used together with an ETK_XETK AML */  
                                };
                            })*;
                        };
                    };
                };
            };
        };
    };
};

/************* start of XCP on different Transport Layers *******************/

  "XCPplus" struct {
    uint;
    taggedstruct Common_Parameters ; /* default parameters */
  
    taggedstruct { /* transport layer specific parameters  */
                   /* overruling of the default parameters */
  
      (block "XCP_ON_CAN" struct {
  
        struct CAN_Parameters ;                   /* specific for CAN      */
        taggedstruct Common_Parameters;           /* overruling of default */
        taggedstruct {
          "TRANSPORT_LAYER_INSTANCE" char[101];
        };   
  
      })*;
  
      (block "XCP_ON_TCP_IP" struct {
  
        struct TCP_IP_Parameters ;                /* specific for TCP_IP   */
        taggedstruct Common_Parameters;           /* overruling of default */
        taggedstruct {
          "TRANSPORT_LAYER_INSTANCE" char[101];
        };
  
      })*;
  
      (block "XCP_ON_UDP_IP" struct {
  
        struct UDP_IP_Parameters ;                /* specific for UDP      */
        taggedstruct Common_Parameters;           /* overruling of default */
        taggedstruct {
          "TRANSPORT_LAYER_INSTANCE" char[101];
        };
  
      })*;
  
      (block "XCP_ON_FLX" struct {
  
        struct FLX_Parameters ;                   /* specific for FLX      */
        taggedstruct Common_Parameters;           /* overruling of default */
        taggedstruct {
          "TRANSPORT_LAYER_INSTANCE" char[101];
        };
  
      })*;
  
    };
  
  };
  
/************* end of XCP on different Transport Layers ********************/


    }; 
  /end A2ML


  /begin MOD_COMMON  ""
    DEPOSIT          ABSOLUTE
    BYTE_ORDER       MSB_LAST
  /end MOD_COMMON

  /begin MOD_PAR     ""
    VERSION          "XCP_1.0.0"
    CUSTOMER_NO      ""
    USER             ""
    PHONE_NO         ""
    ECU              "ETAS AUTOSAR"
    CPU_TYPE         "Tc275"

    /begin MEMORY_SEGMENT Pst80040000 "" CODE FLASH INTERN 0x80040000 0x100000 -1 -1 -1 -1 -1 



    /end MEMORY_SEGMENT
	 
	/begin MEMORY_SEGMENT Dst80140000 "" DATA FLASH INTERN 0x80140000 0x8000 -1 -1 -1 -1 -1 


        /begin IF_DATA XCPplus 0x0102
          /begin SEGMENT
            3       /* segment logical number */
            0x02       /* number of pages */
            0x00       /* address extension */
            0x00       /* compression method */
            0x00       /* encryption method */
            /begin CHECKSUM
                XCP_ADD_14 /* checksum: add bytes to 16bit result */
                MAX_BLOCK_SIZE 0x400
            /end CHECKSUM
            /begin PAGE
              0x00       /* page number */
              ECU_ACCESS_DONT_CARE
              XCP_READ_ACCESS_DONT_CARE
              XCP_WRITE_ACCESS_NOT_ALLOWED
            /end PAGE
            /begin PAGE
              0x01       /* page number */
              ECU_ACCESS_DONT_CARE
              XCP_READ_ACCESS_DONT_CARE
              XCP_WRITE_ACCESS_WITH_ECU_ONLY
            /end PAGE
          /end SEGMENT
        /end IF_DATA
    /end MEMORY_SEGMENT

    /begin MEMORY_SEGMENT Pst80148000 "" CODE FLASH INTERN 0x80148000 0xB6000 -1 -1 -1 -1 -1 



    /end MEMORY_SEGMENT	 
	/begin MEMORY_SEGMENT RamB0000000 "" VARIABLES RAM INTERN 0xB0000000 0x8000 -1 -1 -1 -1 -1 

      /begin IF_DATA XCPplus 0x0102
        /begin SEGMENT
            4       /* segment logical number */
          0x00       /* number of pages        */
          0x00       /* address extension      */
          0x00       /* compression method     */
          0x00       /* encryption method      */
        /end SEGMENT
      /end IF_DATA
    /end MEMORY_SEGMENT 

	
	/begin MEMORY_SEGMENT Ram70000000 "" VARIABLES RAM INTERN 0x70000000 0x1C000 -1 -1 -1 -1 -1 

      /begin IF_DATA XCPplus 0x0102
        /begin SEGMENT
            5       /* segment logical number */
          0x00       /* number of pages        */
          0x00       /* address extension      */
          0x00       /* compression method     */
          0x00       /* encryption method      */
        /end SEGMENT
      /end IF_DATA
    /end MEMORY_SEGMENT

    /begin MEMORY_SEGMENT Ram60000000 "" VARIABLES RAM INTERN 0x60000000 0x1E000 -1 -1 -1 -1 -1 

      /begin IF_DATA XCPplus 0x0102
        /begin SEGMENT
            6       /* segment logical number */
          0x00       /* number of pages        */
          0x00       /* address extension      */
          0x00       /* compression method     */
          0x00       /* encryption method      */
        /end SEGMENT
      /end IF_DATA
    /end MEMORY_SEGMENT

    /begin MEMORY_SEGMENT Ram50000000 "" VARIABLES RAM INTERN 0x50000000 0x1E000 -1 -1 -1 -1 -1 

      /begin IF_DATA XCPplus 0x0102
        /begin SEGMENT
            7       /* segment logical number */
          0x00       /* number of pages        */
          0x00       /* address extension      */
          0x00       /* compression method     */
          0x00       /* encryption method      */
        /end SEGMENT
      /end IF_DATA
    /end MEMORY_SEGMENT
	
	 /begin CALIBRATION_METHOD
      /* name calibration methode         */ "DataSetId"
      /* version calibration metode       */ 256
      /begin CALIBRATION_HANDLE
        /* adr data set id characteristic,dummy */ 0x80145000
      /end CALIBRATION_HANDLE
    /end CALIBRATION_METHOD

  /end MOD_PAR

 /begin IF_DATA XCPplus 0x0102

  /* XcpTransportLayer "XcpTransportLayer" */
   /begin PAG
     /* MAX_SEGMENTS       */ 4
   /end PAG
  /begin XCP_ON_CAN
/************************ start of CAN *********************/
    0x0102                                                /* XCP on CAN version */
    CAN_ID_MASTER 0x220                                   /* CMD/STIM CAN-ID */
                                                          /* master -> slave */
    CAN_ID_SLAVE 0x300                                    /* RES/ERR/EV/SERV/DAQ CAN-ID */
                                                          /* slave -> master */
                                                          /* Bit31= 1: extended identifier */
    BAUDRATE 500000                                      /* BAUDRATE [Hz] */
    SAMPLE_POINT 100                                       /* sample point */
                                                          /* [% complete bit time] */
    BTL_CYCLES 11                                         /* BTL_CYCLES */
                                                          /* [slots per bit time] */
    SJW 0                                                 /* length synchr. segment */
                                                          /* [BTL_CYCLES] */
    /begin EVENT_CAN_ID_LIST
      0                                                   /* reference to EVENT_NUMBER: 2msRstr */
      FIXED         0x310                                /* this Event always on this ID */
    /end EVENT_CAN_ID_LIST
    /begin EVENT_CAN_ID_LIST
      1                                                   /* reference to EVENT_NUMBER: 10msRstr */
      FIXED         0x311                                /* this Event always on this ID */
    /end EVENT_CAN_ID_LIST
    /begin EVENT_CAN_ID_LIST
      2                                                   /* reference to EVENT_NUMBER: 100msRstr */
      FIXED         0x312                                 /* this Event always on this ID */
    /end EVENT_CAN_ID_LIST
    MAX_BUS_LOAD  100                                     /* maximum available bus */

/************************* end of CAN **********************/


  /* XcpTransportLayer "XcpTransportLayer" */
/*************** start of PROTOCOL_LAYER *******************/

  /begin PROTOCOL_LAYER                                   /* At MODULE */

    0x0102                                                /* XCP protocol layer version */

    2000                                                   /* T1 [ms] */
    2000                                                   /* T2 [ms] */
    0                                                     /* T3 [ms] */
    0                                                     /* T4 [ms] */
    0                                                     /* T5 [ms] */
    0                                                     /* T6 [ms] */
    2000                                                     /* T7 [ms] */

    8                                                     /* MAX_CTO */
    8                                                     /* MAX_DTO default for DAQ and STIM */

    BYTE_ORDER_MSB_LAST                                   /* BYTE_ORDER: MOTOROLA */
    ADDRESS_GRANULARITY_BYTE                              /* ADDRESS_GRANULARITY */

    OPTIONAL_CMD GET_SEED
    OPTIONAL_CMD UNLOCK
    OPTIONAL_CMD SET_MTA
    OPTIONAL_CMD UPLOAD
    OPTIONAL_CMD SHORT_UPLOAD
    OPTIONAL_CMD BUILD_CHECKSUM
    OPTIONAL_CMD DOWNLOAD
    OPTIONAL_CMD DOWNLOAD_NEXT
    OPTIONAL_CMD DOWNLOAD_MAX
    OPTIONAL_CMD MODIFY_BITS
    OPTIONAL_CMD SET_CAL_PAGE
    OPTIONAL_CMD GET_CAL_PAGE
    OPTIONAL_CMD GET_PAG_PROCESSOR_INFO
    OPTIONAL_CMD GET_SEGMENT_INFO
    OPTIONAL_CMD GET_PAGE_INFO
    OPTIONAL_CMD COPY_CAL_PAGE
    OPTIONAL_CMD CLEAR_DAQ_LIST
    OPTIONAL_CMD SET_DAQ_PTR
    OPTIONAL_CMD WRITE_DAQ
    OPTIONAL_CMD SET_DAQ_LIST_MODE
    OPTIONAL_CMD START_STOP_DAQ_LIST
    OPTIONAL_CMD START_STOP_SYNCH
    OPTIONAL_CMD GET_DAQ_CLOCK
    OPTIONAL_CMD READ_DAQ
    OPTIONAL_CMD GET_DAQ_PROCESSOR_INFO
    OPTIONAL_CMD GET_DAQ_RESOLUTION_INFO
    OPTIONAL_CMD GET_DAQ_EVENT_INFO
    OPTIONAL_CMD FREE_DAQ
    OPTIONAL_CMD ALLOC_DAQ
    OPTIONAL_CMD ALLOC_ODT
    OPTIONAL_CMD ALLOC_ODT_ENTRY

    COMMUNICATION_MODE_SUPPORTED                          /* optional modes supported */
      BLOCK
        SLAVE                                             /* Slave Block Mode supported  */
        MASTER                                            /* Master Block Mode supported */
          255                                             /* MAX_BS */
          50                                              /* MIN_ST */
    SEED_AND_KEY_EXTERNAL_FUNCTION "XcpSeedNKey.dll"                   /* Name of the SeedAndKey function */
                                                          /* including file extension      */
                                                          /* without path                  */

  /end PROTOCOL_LAYER

/***************** end of PROTOCOL_LAYER *******************/


  /* XcpTransportLayer "XcpTransportLayer" */
/********************* start of DAQ ************************/

  /begin DAQ                                              /* DAQ supported, at MODULE*/
    DYNAMIC                                               /* DAQ_CONFIG_TYPE */
    65535                                                 /* MAX_DAQ */
    3                                                     /* MAX_EVENT_CHANNEL */
    0                                                     /* MIN_DAQ */
    OPTIMISATION_TYPE_DEFAULT                             /* OPTIMISATION_TYPE */
    ADDRESS_EXTENSION_FREE                                /* ADDRESS_EXTENSION */
    IDENTIFICATION_FIELD_TYPE_ABSOLUTE                    /* IDENTIFICATION_FIELD */
    GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE                   /* GRANULARITY_ODT_ENTRY_SIZE_DAQ */
    255                                                   /* MAX_ODT_ENTRY_SIZE_DAQ */
    NO_OVERLOAD_INDICATION                             /* OVERLOAD_INDICATION */
    PRESCALER_SUPPORTED
    /begin TIMESTAMP_SUPPORTED
      1                           /* TIMESTAMP_TICKS */
      SIZE_WORD             /* TIMESTAMP_SIZE */
      UNIT_1MS  /* RESOLUTION OF TIMESTAMP */
    /end TIMESTAMP_SUPPORTED
    /begin DAQ_MEMORY_CONSUMPTION
      4091                                                /* DAQ_MEMORY_LIMIT: in Elements[AG] */
      46                                                  /* DAQ_SIZE: number of elements[AG] per DAQ list */
      6                                                   /* ODT_SIZE: number of elements[AG] per ODT */
      5                                                   /* ODT_ENTRY_SIZE: number of elements[AG] per ODT_entry */
      2                                                   /* ODT_DAQ_BUFFER_ELEMENT_SIZE: number of */
                                                          /* payload elements[AG]*factor = sizeof(send buffer)[AG] */
      0                                                   /* ODT_STIM_BUFFER_ELEMENT_SIZE: number of */
                                                          /* payload elements[AG]*factor = sizeof(receive buffer)[AG] */
    /end DAQ_MEMORY_CONSUMPTION

/******************* start of EVENT ************************/

    /begin EVENT                                          /* EVENT               */
      "XcpEvent_2ms_Raster"                             /* EVENT_CHANNEL_NAME       */
      "2msRstr"                                             /* EVENT_CHANNEL_SHORT_NAME */
      0                                                   /* EVENT_CHANNEL_NUMBER     */
      DAQ                                                 /* EVENT_CHANNEL_TYPE     */
      1                                                   /* MAX_DAQ_LIST */
      2                                                  /* EVENT_CHANNEL_TIME_CYCLE */
      6                                                   /* EVENT_CHANNEL_TIME_UNIT: UNIT_1MS */
      3                                                   /* EVENT_CHANNEL_PRIORITY (0xFF = highest) */
    /end EVENT

    /begin EVENT                                          /* EVENT               */
      "XcpEvent_10ms_Raster"                             /* EVENT_CHANNEL_NAME       */
      "10msRstr"                                             /* EVENT_CHANNEL_SHORT_NAME */
      1                                                   /* EVENT_CHANNEL_NUMBER     */
      DAQ                                                 /* EVENT_CHANNEL_TYPE     */
      1                                                   /* MAX_DAQ_LIST */
      10                                                  /* EVENT_CHANNEL_TIME_CYCLE */
      6                                                   /* EVENT_CHANNEL_TIME_UNIT: UNIT_1MS */
      2                                                   /* EVENT_CHANNEL_PRIORITY (0xFF = highest) */
    /end EVENT

    /begin EVENT                                          /* EVENT               */
      "XcpEvent_100ms_Raster"                             /* EVENT_CHANNEL_NAME       */
      "100msRstr"                                             /* EVENT_CHANNEL_SHORT_NAME */
      2                                                   /* EVENT_CHANNEL_NUMBER     */
      DAQ                                                 /* EVENT_CHANNEL_TYPE     */
      1                                                   /* MAX_DAQ_LIST */
      10                                                  /* EVENT_CHANNEL_TIME_CYCLE */
      7                                                   /* EVENT_CHANNEL_TIME_UNIT: UNIT_10MS */
      1                                                   /* EVENT_CHANNEL_PRIORITY (0xFF = highest) */
    /end EVENT

/********************* end of EVENT ************************/

  /end DAQ

/********************* end of DAQ **************************/

  /* XcpTransportLayer "XcpTransportLayer" */
  TRANSPORT_LAYER_INSTANCE "XCP_TPL"

  /end XCP_ON_CAN


 /end IF_DATA


/* ---------------------------------------------------------------------------*/


  

/* ---------------------------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/



/* ---------------------------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/

  /begin FUNCTION __DDS_EXPA2_DEFAULT_FUNC__
   "__DDS_EXPA2_DEFAULT_FUNC__"
  /end FUNCTION

/* ---------------------------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/

  /begin COMPU_METHOD ident
    ""
    RAT_FUNC
    "%8.4"
    ""
    COEFFS 0 1 0 0 0 1
  /end COMPU_METHOD

/begin COMPU_METHOD
    stDrvCtl_Verb
    ""
    TAB_VERB
    "%2.1"
    "-"
    COMPU_TAB_REF stDrvCtl_List
    
/end COMPU_METHOD

/begin COMPU_METHOD
    stSysCtl_Verb
    ""
    TAB_VERB
    "%2.1"
    "-"
    COMPU_TAB_REF stSysCtl_List
    
/end COMPU_METHOD

/begin COMPU_METHOD
    stDern_Verb
    ""
    TAB_VERB
    "%2.1"
    "-"
    COMPU_TAB_REF stDern_List
    
/end COMPU_METHOD
/* ---------------------------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/
  /begin COMPU_VTAB

    stDrvCtl_List
    ""
    TAB_VERB
    20

    0 "Drv_Initial"
    1 "Drv_MocSop"
    2 "Drv_SensCalFW"
    3 "Drv_Standby"
    4 "Drv_Run"
    5 "Drv_OffsetAcc"
    6 "Drv_OffsetFw"
    7 "Drv_Discharge"
    8 "Drv_Failure"
    9 "Drv_TrqCtl"
   10 "Drv_nCtlExt"
   11 "Drv_inActive"
   12 "Drv_nCtlInt"
   13 "Drv_IsCtl"
   14 "Drv_UdcCtl"
   15 "Drv_UdcBatCtl"
   16 "Drv_FrWCtl"
   17 "Drv_IdLe"
   18 "Drv_TestBench"
   19 "Drv_OffsetCal"

    DEFAULT_VALUE "---"
  /end COMPU_VTAB

  /begin COMPU_VTAB

    stSysCtl_List
    ""
    TAB_VERB
    5

    0 "PreDriveMod"
    1 "DriveMod"
    2 "PostDriveMod"
    3 "ShutDownMod"
    4 "FaultMod"

    DEFAULT_VALUE "---"
  /end COMPU_VTAB

  /begin COMPU_VTAB

    stDern_List
    ""
    TAB_VERB
    9

    0 "bDern_Inactive"
    1 "bDern_ExCTrq"
    2 "bDern_StrTemp"
    3 "bDern_TempIGBT"
    4 "bDern_N"
    5 "bDern_OvrIdc"
    6 "bDern_UndrUdc"
    7 "bDern_OvrUdc"
    8 "bDern_CAN"

    DEFAULT_VALUE "---"
  /end COMPU_VTAB

/* ---------------------------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/
  /begin RECORD_LAYOUT RL.FNC.FLOAT32_IEEE.ROW_DIR
    FNC_VALUES 1 FLOAT32_IEEE ROW_DIR DIRECT
  /end RECORD_LAYOUT

  /begin RECORD_LAYOUT STANDARD_VALUE_S8
    FNC_VALUES                            /* description of function value: */
    1                                     /* position in memory */
    SBYTE                                 /* data type of the constant */
    COLUMN_DIR                            /* deposited in columns (don't care) */
    DIRECT                                /* direct addressing */
  /end RECORD_LAYOUT

  /begin RECORD_LAYOUT STANDARD_VALUE_S16
    FNC_VALUES                            /* description of function value: */
    1                                     /* position in memory */
    SWORD                                 /* data type of the constant */
    COLUMN_DIR                            /* deposited in columns (don't care) */
    DIRECT                                /* direct addressing */
  /end RECORD_LAYOUT

  /begin RECORD_LAYOUT STANDARD_VALUE_S32
    FNC_VALUES                            /* description of function value: */
    1                                     /* position in memory */
    SLONG                                 /* data type of the constant */
    COLUMN_DIR                            /* deposited in columns (don't care) */
    DIRECT                                /* direct addressing */
  /end RECORD_LAYOUT

  /begin RECORD_LAYOUT STANDARD_VALUE_U8
    FNC_VALUES                            /* description of function value: */
    1                                     /* position in memory */
    UBYTE                                 /* data type of the constant */
    COLUMN_DIR                            /* deposited in columns (don't care) */
    DIRECT                                /* direct addressing */
  /end RECORD_LAYOUT

  /begin RECORD_LAYOUT STANDARD_VALUE_U16
    FNC_VALUES                            /* description of function value: */
    1                                     /* position in memory */
    UWORD                                 /* data type of the constant */
    COLUMN_DIR                            /* deposited in columns (don't care) */
    DIRECT                                /* direct addressing */
  /end RECORD_LAYOUT

  /begin RECORD_LAYOUT STANDARD_VALUE_U32
    FNC_VALUES                            /* description of function value: */
    1                                     /* position in memory */
    ULONG                                 /* data type of the constant */
    COLUMN_DIR                            /* deposited in columns (don't care) */
    DIRECT                                /* direct addressing */
  /end RECORD_LAYOUT

  /begin RECORD_LAYOUT STANDARD_VALUE_R32
    FNC_VALUES                            /* description of function value: */
    1                                     /* position in memory */
    FLOAT32_IEEE                          /* data type of the constant */
    COLUMN_DIR                            /* deposited in columns (don't care) */
    DIRECT                                /* direct addressing */
  /end RECORD_LAYOUT



 /end MODULE
/end PROJECT
